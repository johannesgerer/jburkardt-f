<html>

  <head>
    <title>
      OPENMP_STUBS - A FORTRAN90 Stub Library for OpenMP
    </title>
  </head>

  <body bgcolor="#EEEEEE" link="#CC0000" alink="#FF3300" vlink="#000055">

    <h1 align = "center">
      OPENMP_STUBS <br> A FORTRAN90 Stub Library for OpenMP
    </h1>

    <hr>

    <p>
      <b>OPENMP_STUBS</b>
      is a FORTRAN90 library which
      constitutes a stub implementation of the OpenMP standard for
      shared memory parallel programming.
    </p>

    <p>
      A stub library is useful when you want to try out a program on a system
      that does not have OpenMP, or when you need to have a formally complete
      program to analyze, or in other cases where you want to ignore the actual
      OpenMP library.  A stub library can also help to understand the structure
      of the actual library.
    </p>

    <h3 align = "center">
      Licensing:
    </h3>

    <p>
      The computer code and data files described and made available on this web page
      are distributed under
      <a href = "../../txt/gnu_lgpl.txt">the GNU LGPL license.</a>
    </p>

    <h3 align = "center">
      Languages:
    </h3>

    <p>
      <b>OPENMP_STUBS</b> is available in
      <a href = "../../c_src/openmp_stubs/openmp_stubs.html">a C version</a> and
      <a href = "../../cpp_src/openmp_stubs/openmp_stubs.html">a C++ version</a> and
      <a href = "../../f77_src/openmp_stubs/openmp_stubs.html">a FORTRAN77 version</a> and
      <a href = "../../f_src/openmp_stubs/openmp_stubs.html">a FORTRAN90 version</a>.
    </p>

    <h3 align = "center">
      Related Data and Programs:
    </h3>

    <p>
      <a href = "../../f_src/dijkstra_openmp/dijkstra_openmp.html">
      DIJKSTRA_OPENMP</a>,
      a FORTRAN90 program which
      uses OpenMP to parallelize a simple example of Dijkstra's
      minimum distance algorithm for graphs.
    </p>

    <p>
      <a href = "../../f_src/fft_openmp/fft_openmp.html">
      FFT_OPENMP</a>,
      a FORTRAN90 program which
      demonstrates the computation of a Fast Fourier Transform
      in parallel, using OpenMP.
    </p>

    <p>
      <a href = "../../f_src/heated_plate_openmp/heated_plate_openmp.html">
      HEATED_PLATE_OPENMP</a>,
      a FORTRAN90 program which
      solves the steady (time independent) heat equation in a 2D
      rectangular region, using OpenMP to run in parallel.
    </p>

    <p>
      <a href = "../../f_src/hello_openmp/hello_openmp.html">
      HELLO_OPENMP</a>,
      a FORTRAN90 program which
      prints out "Hello, world!" using the OpenMP parallel programming environment.
    </p>

    <p>
      <a href = "../../f_src/md_openmp/md_openmp.html">
      MD_OPENMP</a>,
      a FORTRAN90 program which
      carries out a molecular dynamics simulation using OpenMP.
    <p>

    <p>
      <a href = "../../f_src/multitask_openmp/multitask_openmp.html">
      MULTITASK_OPENMP</a>,
      a FORTRAN90 program which
      demonstrates how to "multitask", that is, to execute several unrelated
      and distinct tasks simultaneously, using OpenMP for parallel execution.
    </p>

    <p>
      <a href = "../../f_src/mxv_openmp/mxv_openmp.html">
      MXM_OPENMP</a>,
      a FORTRAN90 program which
      computes a dense matrix product C=A*B,
      using OpenMP for parallel execution.
    <p>

    <p>
      <a href = "../../f_src/mxv_openmp/mxv_openmp.html">
      MXV_OPENMP</a>,
      a FORTRAN90 program which
      compares the performance of plain vanilla Fortran and the FORTRAN90
      intrinsic routine MATMUL, for the matrix multiplication problem
      y=A*x, with and without parallelization by OpenMP.
    <p>

    <p>
      <a href = "../../f_src/openmp/openmp.html">
      OPENMP</a>,
      FORTRAN90 programs which
      illustrate the use of the OpenMP application program interface
      for carrying out parallel computations in a shared memory environment.
    </p>

    <p>
      <a href = "../../f_src/prime_openmp/prime_openmp.html">
      PRIME_OPENMP</a>,
      a FORTRAN90 program which
      counts the number of primes between 1 and N, using OpenMP for parallel execution.
    </p>

    <p>
      <a href = "../../f_src/quad_openmp/quad_openmp.html">
      QUAD_OPENMP</a>,
      a FORTRAN90 program which
      approximates an integral using a quadrature rule, and carries out the
      computation in parallel using OpenMP.
    </p>

    <p>
      <a href = "../../f_src/satisfy_openmp/satisfy_openmp.html">
      SATISFY_OPENMP</a>,
      a FORTRAN90 program which
      demonstrates, for a particular circuit, an exhaustive search
      for solutions of the circuit satisfy problem,
      using OpenMP for parallel execution.
    <p>

    <p>
      <a href = "../../f_src/schedule_openmp/schedule_openmp.html">
      SCHEDULE_OPENMP</a>,
      a FORTRAN90 program which
      demonstrates the default, static, and dynamic methods of scheduling
      loop iterations in OpenMP to avoid work imbalance.
    <p>

    <p>
      <a href = "../../f_src/sgefa_openmp/sgefa_openmp.html">
      SGEFA_OPENMP</a>,
      a FORTRAN90 program which
      reimplements the SGEFA/SGESL linear algebra routines from
      LINPACK for use with OpenMP.
    </p>

    <p>
      <a href = "../../f_src/ziggurat_openmp/ziggurat_openmp.html">
      ZIGGURAT_OPENMP</a>,
      a FORTRAN90 program which
      demonstrates how the ZIGGURAT library can be used to generate random numbers
      in an OpenMP parallel program.
    </p>

    <h3 align = "center">
      Reference:
    </h3>

    <p>
      <ol>
        <li>
          Rohit Chandra, Leonardo Dagum, Dave Kohr, Dror Maydan,
          Jeff McDonald, Ramesh Menon,<br>
          Parallel Programming in OpenMP,<br>
          Morgan Kaufmann, 2001,<br>
          ISBN: 1-55860-671-8,<br>
          LC: QA76.642.P32.
        </li>
        <li>
          Barbara Chapman, Gabriele Jost, Ruud vanderPas, David Kuck,<br>
          Using OpenMP: Portable Shared Memory Parallel Processing,<br>
          MIT Press, 2007,<br>
          ISBN13: 978-0262533027.
        </li>
        <li>
          <a href = "http://www.openmp.org/">The OpenMP web site</a>
        </li>
        <li>
          OpenMP Architecture Review Board,<br>
          OpenMP Application Program Interface,<br>
          Version 3.1,<br>
          July 2011.
        </li>
      </ol>
    </p>

    <h3 align = "center">
      Source Code:
    </h3>

    <p>
      <ul>
        <li>
          <a href = "openmp_stubs.f90">openmp_stubs.f90</a>, the source code.
        </li>
        <li>
          <a href = "openmp_stubs.sh">openmp_stubs.sh</a>,
          commands to compile the source code.
        </li>
        <li>
          <a href = "omp_lib.h">omp_lib.h</a>,
          a simple "include" file that declares the type of the
          functions that are part of the library.
        </li>
        <li>
          <a href = "omp_lib_kinds.h">omp_lib_kinds.h</a>,
          an include file that declares the integer kind of several
          OpenMP variables.
        </li>
        <li>
          <a href = "omp_stubs.f90">omp_stubs.f90</a>,
          a Fortran interface declaration module.
        </li>
      </ul>
    </p>

    <h3 align = "center">
      Examples and Tests:
    </h3>

    <p>
      <i>
        Note that these examples are normally run in parallel with OpenMP.
        The point being made here is that such programs can be run sequentially,
        as though OpenMP were available, by calling the OPENMP_STUBS library.
        They don't run well (fast) - it's just remarkable that they run at all.
      </i>
    </p>

    <p>
      <b>COMPUTE_PI</b> shows how information can be shared.
      Several processors need to compute pieces of a sum that will
      approximate pi.
      <ul>
        <li>
          <a href = "../../f_src/openmp/compute_pi.f90">compute_pi.f90</a>,
          the source code;
        </li>
        <li>
          <a href = "compute_pi.sh">compute_pi.sh</a>,
          BASH commands to compile, link, load and run the program
          with the OPENMP_STUBS library.
        </li>
        <li>
          <a href = "compute_pi_output.txt">compute_pi_output.txt</a>,
          the output file;
        </li>
      </ul>
    </p>

    <p>
      <b>HELLO</b> is a very simple program which calls an
      OpenMP subroutine to set the number of threads, and then has
      each thread say hello;
      <ul>
        <li>
          <a href = "../../f_src/openmp/hello.f90">hello.f90</a>,
          the source code;
        </li>
        <li>
          <a href = "hello.sh">hello.sh</a>,
          BASH commands to compile, link, load and run the program
          with the OPENMP_STUBS library.
        </li>
        <li>
          <a href = "hello_output.txt">hello_output.txt</a>,
          the output file;
        </li>
      </ul>
    </p>

    <p>
      <b>HELMHOLTZ</b> is a more extensive program that solves
      the Helmholtz equation on a regular grid, using a Jacobi iterative
      linear equation solver with overrelaxation;
      <ul>
        <li>
          <a href = "../../f_src/openmp/helmholtz.f90">helmholtz.f90</a>,
          the source code;
        </li>
        <li>
          <a href = "helmholtz.sh">helmholtz.sh</a>,
          BASH commands to compile, link, load and run the program
          with the OPENMP_STUBS library.
        </li>
        <li>
          <a href = "helmholtz_output.txt">helmholtz_output.txt</a>,
          the output file;
        </li>
      </ul>
    </p>

    <h3 align = "center">
      List of Routines:
    </h3>

    <p>
      <i>
        Again, please don't be confused.  These routines have the same names
        as the real OpenMP library; they just don't do anything.  Well, not much,
        anyway.  They do just enough to let a program run in sequential mode.
      </i>
    </p>

    <p>
      <ul>
        <li>
          <b>OMP_DESTROY_LOCK</b> destroys a simple lock.
        </li>
        <li>
          <b>OMP_DESTROY_NEST_LOCK</b> destroys a nestable lock.
        </li>
        <li>
          <b>OMP_GET_ACTIVE_LEVEL</b> returns the number of nested active parallel regions.
        </li>
        <li>
          <b>OMP_GET_ANCESTOR_THREAD_NUM</b> returns the thread number of the ancestor of this thread.
        </li>
        <li>
          <b>OMP_GET_DYNAMIC</b> reports if dynamic adjustment of thread number is allowed.
        </li>
        <li>
          <b>OMP_GET_LEVEL</b> returns the number of nested parallel regions enclosing this task.
        </li>
        <li>
          <b>OMP_GET_MAX_ACTIVE_LEVELS</b> gets the maximum number of nested active parallel regions.
        </li>
        <li>
          <b>OMP_GET_MAX_THREADS</b> returns the default number of threads.
        </li>
        <li>
          <b>OMP_GET_NESTED</b> reports if nested parallelism has been enabled.
        </li>
        <li>
          <b>OMP_GET_NUM_PROCS</b> returns the number of processors available to the program.
        </li>
        <li>
          <b>OMP_GET_NUM_THREADS</b> returns the number of threads in the current team.
        </li>
        <li>
          <b>OMP_GET_SCHEDULE</b> returns information about the "runtime" schedule.
        </li>
        <li>
          <b>OMP_GET_TEAM_SIZE</b> returns the size of the thread team for a given level.
        </li>
        <li>
          <b>OMP_GET_THREAD_LIMIT</b> returns the maximum number of OpenMP threads available.
        </li>
        <li>
          <b>OMP_GET_THREAD_NUM</b> returns the thread number of a thread in a team.
        </li>
        <li>
          <b>OMP_GET_WTICK</b> returns the precision of the timer used by OMP_GET_WTIME.
        </li>
        <li>
          <b>OMP_GET_WTIME</b> returns elapsed wall clock time in seconds.
        </li>
        <li>
          <b>OMP_IN_FINAL</b> is true if the routine is executed in a final task region.
        </li>
        <li>
          <b>OMP_IN_PARALLEL</b> returns TRUE if the call is made from a parallel region.
        </li>
        <li>
          <b>OMP_INIT_LOCK</b> initializes a simple lock.
        </li>
        <li>
          <b>OMP_INIT_NEST_LOCK</b> initializes a nestable lock.
        </li>
        <li>
          <b>OMP_SET_DYNAMIC</b> enables dynamic adjustment of the number of threads.
        </li>
        <li>
          <b>OMP_SET_LOCK</b> sets a simple lock.
        </li>
        <li>
          <b>OMP_SET_MAX_ACTIVE_LEVELS</b> limits the number of nested active parallel regions.
        </li>
        <li>
          <b>OMP_SET_NEST_LOCK</b> sets a nestable lock.
        </li>
        <li>
          <b>OMP_SET_NESTED</b> controls the use of nested parallelism.
        </li>
        <li>
          <b>OMP_SET_NUM_THREADS</b> sets the number of threads.
        </li>
        <li>
          <b>OMP_SET_SCHEDULE</b> chooses the schedule when "runtime" is the schedule kind.
        </li>
        <li>
          <b>OMP_TEST_LOCK</b> tests a simple lock.
        </li>
        <li>
          <b>OMP_TEST_NEST_LOCK</b> tests a nestable lock.
        </li>
        <li>
          <b>OMP_UNSET_LOCK</b> unsets a simple lock.
        </li>
        <li>
          <b>OMP_UNSET_NEST_LOCK</b> unsets a nestable lock.
        </li>
      </ul>
    </p>

    <p>
      You can go up one level to <a href = "../f_src.html">
      the FORTRAN90 source codes</a>.
    </p>

    <hr>

    <i>
      Last revised on 14 May 2012.
    </i>

    <!-- John Burkardt -->

  </body>

  <!-- Initial HTML skeleton created by HTMLINDEX. -->

</html>
