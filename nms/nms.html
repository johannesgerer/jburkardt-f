<html>

  <head>
    <title>
      NMS - Numerical Analysis Library
    </title>
  </head>

  <body bgcolor="#EEEEEE" link="#CC0000" alink="#FF3300" vlink="#000055">

    <h1 align = "center">
      NMS <br> Numerical Analysis Library
    </h1>

    <hr>

    <p>
      <b>NMS</b>
      is a FORTRAN90 library which
      is a good beginner's
      mathematical library, with well tested routines for standard problems.
    </p>

    <p>
      <b>NMS</b> accompanies the text
      "Numerical Methods and Software".  The book is a modern discussion
      of current numerical algorithms and software.  The software that comes
      with the book has been extracted from standard software libraries,
      particularly the SLATEC library.  Thus the book is also a good
      introduction to the use of a portion of the SLATEC library, which
      does not have a widely available solid hardcopy reference.
    </p>

    <p>
      In particular, <b>NMS</b> includes some or all of:
      <ul>
        <li>
          BLAS1, the Basis Linear Algebra Subprograms, Level 1;
        </li>
        <li>
          DDRIV, for integrating systems of ODE's;
        </li>
        <li>
          FFTPACK, for Fast Fourier Transforms,<br>
          (Paul Swarztrauber);
        </li>
        <li>
          FNLIB, Wayne Fullerton's special function package,
        </li>
        <li>
          FUNPACK, Daniel Amos's special function package,
        </li>
        <li>
          LINPACK, for solving linear systems.
        </li>
        <li>
          MACHINE, for reporting values of machine arithmetic constants.
        </li>
        <li>
          PCHIP, Piecewise Cubic Hermite Interpolation Package,<br>
          (Fritsch and Carlson);
        </li>
        <li>
          QUADPACK, for approximate integration;
        </li>
        <li>
          UNCMIN, for the unconstrained minimization of a function
          of several variables.
        </li>
        <li>
          XERROR, for handling run time errors.
        </li>
      </ul>
    </p>

    <h3 align = "center">
      Languages:
    </h3>

    <p>
      <b>NMS</b> is available in
      <a href = "../../f77_src/nms/nms.html">a FORTRAN77 version</a> and
      <a href = "../../f_src/nms/nms.html">a FORTRAN90 version</a>.
    </p>

    <h3 align = "center">
      Related Data and Programs:
    </h3>

    <p>
      <a href = "../../f_src/distance_to_position/distance_to_position.html">
      DISTANCE_TO_POSITION</a>,
      a FORTRAN90 program which
      estimates the positions of cities based on a city-to-city distance table.
      It uses UNCMIN from NMS to solve this problem.
    </p>

    <p>
      <a href = "../../f_src/fftpack5/fftpack5.html">
      FFTPACK5</a>,
      a FORTRAN90 library which
      contains version 5 of FFTPACK.
    </p>

    <p>
      <a href = "../../f_src/machine/machine.html">
      MACHINE</a>,
      a FORTRAN90 library which
      reports the value of machine
      arithmetic constants.
    </p>

    <p>
      <a href = "../../f_src/ode/ode.html">
      ODE</a>,
      a FORTRAN90 library which
      implements the Shampine and Gordon ODE solver.
    </p>

    <p>
      <a href = "../../f_src/qr_solve/qr_solve.html">
      QR_SOLVE</a>,
      a FORTRAN90 library which
      computes the least squares solution of a linear system A*x=b.
    </p>

    <p>
      <a href = "../../f_src/quadpack/quadpack.html">
      QUADPACK</a>,
      a FORTRAN90 library which
      approximates integrals of functions.
    </p>

    <p>
      <a href = "../../f_src/reactor_simulation/reactor_simulation.html">
      REACTOR_SIMULATION</a>,
      a FORTRAN90 program which
      is a simple Monte Carlo simulation of the shielding effect of a slab
      of a certain thickness in front of a neutron source.  This program was
      provided as an example with the book "Numerical Methods and Software."
    </p>

    <p>
      <a href = "../../f_src/rkf45/rkf45.html">
      RKF45</a>,
      a FORTRAN90 library which
      is a Runge-Kutta-Fehlberg ODE solver.
    </p>

    <p>
      <a href = "../../f_src/slatec/slatec.html">
      SLATEC</a>,
      a FORTRAN90 library which
      evaluates many special functions.
    </p>

    <p>
      <a href = "../../f_src/xerror/xerror.html">
      XERROR</a>,
      a FORTRAN90 library which
      is designed to report and handle errors detected during program execution.
    </p>

    <h3 align = "center">
      Reference:
    </h3>

    <p>
      <ol>
        <li>
          Milton Abramowitz, Irene Stegun,<br>
          Handbook of Mathematical Functions,<br>
          National Bureau of Standards, 1964,<br>
          ISBN: 0-486-61272-4,<br>
          LC: QA47.A34.
        </li>
        <li>
          Donald Amos, SL Daniel, MK Weston,<br>
          CDC 6600 subroutines IBESS and JBESS for Bessel functions
          I(NU,X) and J(NU,X),<br>
          ACM Transactions on Mathematical Software,<br>
          Volume 3, pages 76-92, 1977.
        </li>
        <li>
          Paul Bratley, Bennett Fox, Linus Schrage,<br>
          A Guide to Simulation,<br>
          Second Edition,<br>
          Springer, 1987,<br>
          ISBN: 0387964673,<br>
          LC: QA76.9.C65.B73.
        </li>
        <li>
          Richard Brent,<br>
          Algorithms for Minimization without Derivatives,<br>
          Dover, 2002,<br>
          ISBN: 0-486-41998-3,<br>
          LC: QA402.5.B74.
        </li>
        <li>
          Roger Broucke,<br>
          Algorithm 446:
          Ten Subroutines for the Manipulation of Chebyshev Series,<br>
          Communications of the ACM,<br>
          Volume 16, Number 4, April 1973, pages 254-256.
        </li>
        <li>
          Bill Buzbee,<br>
          The SLATEC Common Math Library,<br>
          in Sources and Development of Mathematical Software,<br>
          edited by Wayne Cowell,<br>
          Prentice-Hall, 1984,<br>
          ISBN: 0-13-823501-5,<br>
          LC: QA76.95.S68.
        </li>
        <li>
          Carl deBoor,<br>
          A Practical Guide to Splines,<br>
          Springer, 2001,<br>
          ISBN: 0387953663,<br>
          LC: QA1.A647.v27.
        </li>
        <li>
          Jacob Dekker,<br>
          Finding a Zero by Means of Successive Linear Interpolation,<br>
          in Constructive Aspects of the Fundamental Theorem of Algebra,<br>
          edited by Bruno Dejon, Peter Henrici,<br>
          Wiley, 1969,<br>
          ISBN: 0471203009,<br>
          LC: QA212.C65.
        </li>
        <li>
          John Dennis, Robert Schnabel,<br>
          Numerical Methods for Unconstrained Optimization
          and Nonlinear Equations,<br>
          SIAM, 1996,<br>
          ISBN13: 978-0-898713-64-0,<br>
          LC: QA402.5.D44.
        </li>
        <li>
          Jack Dongarra, Jim Bunch, Cleve Moler, Pete Stewart,<br>
          LINPACK User's Guide,<br>
          SIAM, 1979,<br>
          ISBN13: 978-0-898711-72-1,<br>
          LC: QA214.L56.
        </li>
        <li>
          Bennett Fox,<br>
          Algorithm 647:
          Implementation and Relative Efficiency of Quasirandom
          Sequence Generators,<br>
          ACM Transactions on Mathematical Software,<br>
          Volume 12, Number 4, December 1986, pages 362-376.
        </li>
        <li>
          Leslie Fox, Ian Parker,<br>
          Chebyshev Polynomials in Numerical Analysis,<br>
          Oxford Press, 1968,<br>
          LC: QA297.F65.
        </li>
        <li>
          Phyllis Fox, Andrew Hall, Norman Schryer,<br>
          Algorithm 528:
          Framework for a Portable Library,<br>
          ACM Transactions on Mathematical Software,<br>
          Volume 4, Number 2, June 1978, page 176-188.
        </li>
        <li>
          Fred Fritsch, Judy Butland,<br>
          A Method for Constructing Local Monotone Piecewise
          Cubic Interpolants,<br>
          SIAM Journal on Scientific and Statistical Computing,<br>
          Volume 5, Number 2, June 1984, pages 300-304.
        </li>
        <li>
          Fred Fritsch, Ralph Carlson,<br>
          Monotone Piecewise Cubic Interpolation,<br>
          SIAM Journal on Numerical Analysis,<br>
          Volume 17, Number 2, April 1980, pages 238-246.
        </li>
        <li>
          Charles Gear,<br>
          Numerical Initial Value Problems in Ordinary Differential
          Equations,<br>
          Prentice-Hall, 1971,<br>
          ISBN: 0136266061,<br>
          LC: QA372.G4.
        </li>
        <li>
          Ron Jones, David Kahaner,<br>
          XERROR, The SLATEC Error Handling Package,<br>
          Software: Practice and Experience,<br>
          Volume 13, Number 3, 1983, pages 251-257.
        </li>
        <li>
          David Kahaner, Cleve Moler, Steven Nash,<br>
          Numerical Methods and Software,<br>
          Prentice Hall, 1989,<br>
          ISBN: 0-13-627258-4,<br>
          LC: TA345.K34.
        </li>
        <li>
          Charles Lawson, Richard Hanson, David Kincaid, Fred Krogh,<br>
          Algorithm 539:
          Basic Linear Algebra Subprograms for Fortran Usage,<br>
          ACM Transactions on Mathematical Software,<br>
          Volume 5, Number 3, September 1979, pages 308-323.
        </li>
        <li>
          Pierre LEcuyer,<br>
          Random Number Generation,<br>
          in Handbook of Simulation,<br>
          edited by Jerry Banks,<br>
          Wiley, 1998,<br>
          ISBN: 0471134031,<br>
          LC: T57.62.H37.
        </li>
        <li>
          Peter Lewis, Allen Goodman, James Miller,<br>
          A Pseudo-Random Number Generator for the System/360,<br>
          IBM Systems Journal,<br>
          Volume 8, Number 2, 1969, pages 136-143.
        </li>
        <li>
          George Marsaglia, Wai Wan Tsang,<br>
          A fast, easily implemented method for sampling from decreasing or
          symmetric unimodal density functions,<br>
          SIAM Journal of Scientific and Statistical Computing,<br>
          Volume 5, Number 2, June 1984, pages 349-359.
        </li>
        <li>
          Jorge More, Burton Garbow, Kenneth Hillstrom,<br>
          User Guide for MINPACK-1,<br>
          Technical Report ANL-80-74,<br>
          Argonne National Laboratory, 1980.
        </li>
        <li>
          Frank Olver,<br>
          Tables of Bessel Functions of Moderate or Large Orders,<br>
          NPL Mathematical Tables, Volume 6,<br>
          Her Majesty's Stationery Office, London, 1962.
        </li>
        <li>
          Robert Piessens, Elise deDoncker-Kapenga,
          Christian Ueberhuber, David Kahaner,<br>
          QUADPACK: A Subroutine Package for Automatic Integration,<br>
          Springer, 1983,<br>
          ISBN: 3540125531,<br>
          LC: QA299.3.Q36.
        </li>
        <li>
          Michael Powell,<br>
          A Hybrid Method for Nonlinear Equations,<br>
          in Numerical Methods for Nonlinear Algebraic Equations,<br>
          edited by Philip Rabinowitz,<br>
          Gordon and Breach, 1970,<br>
          ISBN13: 978-0677142302,<br>
          LC: QA218.N85.
        </li>
        <li>
          Robert Schnabel, John Koontz, Barry Weiss,<br>
          A modular system of algorithms for unconstrained minimization,<br>
          Technical Report CU-CS-240-82,<br>
          Computer Science Department,<br>
          University of Colorado at Boulder, 1982.
        </li>
        <li>
          Lawrence Shampine, Herman Watts,<br>
          ZEROIN, a Root-Solving Routine,<br>
          Technical Report: SC-TM-70-631,<br>
          Sandia National Laboratories, September 1970.
        </li>
        <li>
          Paul Swarztrauber,<br>
          Vectorizing the FFT's,<br>
          in Parallel Computations,<br>
          edited by Garry Rodrigue,<br>
          Academic Press, 1982,<br>
          ISBN: 0125921012,<br>
          LC: QA76.6.P348.
        </li>
        <li>
          Stephen Wolfram,<br>
          The Mathematica Book,<br>
          Fourth Edition,<br>
          Cambridge University Press, 1999,<br>
          ISBN: 0-521-64314-7,<br>
          LC: QA76.95.W65.
        </li>
      </ol>
    </p>

    <h3 align = "center">
      Source Code:
    </h3>

    <p>
      <ul>
        <li>
          <a href = "nms.f90">nms.f90</a>, the source code;
        </li>
        <li>
          <a href = "nms.sh">nms.sh</a>,
          commands to compile the source code;
        </li>
      </ul>
    </p>

    <h3 align = "center">
      Examples and Tests:
    </h3>

    <p>
      <ul>
        <li>
          <a href = "nms_prb.f90">nms_prb.f90</a>, the calling program;
        </li>
        <li>
          <a href = "nms_prb.sh">nms_prb.sh</a>,
          commands to compile, link and run the calling program;
        </li>
        <li>
          <a href = "nms_prb_output.txt">nms_prb_output.txt</a>,
          the output file.
        </li>
        <li>
          <a href = "co2.dat">co2.dat</a>, sample data needed for a test.
        </li>
        <li>
          <a href = "elnino.dat">elnino.dat</a>, sample data needed for a test.
        </li>
        <li>
          <a href = "sunspot.dat">sunspot.dat</a>, sample data needed for a test.
        </li>
      </ul>
    </p>

    <h3 align = "center">
      List of Routines:
    </h3>

    <p>
      <ul>
        <li>
          <b>AIRY_AI_VALUES</b> returns some values of the Airy Ai(x) function.
        </li>
        <li>
          <b>AIRY_AI_PRIME_VALUES</b> returns some values of the Airy function Ai'(x).
        </li>
        <li>
          <b>AIRY_BI_VALUES</b> returns some values of the Airy Bi(x) function.
        </li>
        <li>
          <b>AIRY_BI_PRIME_VALUES</b> returns some values of the Airy function Bi'(x).
        </li>
        <li>
          <b>ALNGAM</b> computes the log of the absolute value of the Gamma function.
        </li>
        <li>
          <b>ASYJY</b> computes high order Bessel functions J and Y.
        </li>
        <li>
          <b>BAKSLV</b> solves A'*x=b where A is a lower triangular matrix.
        </li>
        <li>
          <b>BERNSTEIN_POLY_VALUES</b> returns some values of the Bernstein polynomials.
        </li>
        <li>
          <b>BESI0</b> computes the hyperbolic Bessel function of the first kind, order zero.
        </li>
        <li>
          <b>BESI0E</b> computes the scaled hyperbolic Bessel function I0(X).
        </li>
        <li>
          <b>BESJ</b> computes a sequence of J Bessel functions of increasing order.
        </li>
        <li>
          <b>BESSEL_I0_VALUES</b> returns some values of the I0 Bessel function.
        </li>
        <li>
          <b>BESSEL_J0_VALUES</b> returns some values of the J0 Bessel function.
        </li>
        <li>
          <b>BESSEL_J1_VALUES</b> returns some values of the J1 Bessel function.
        </li>
        <li>
          <b>BESSEL_JN_VALUES</b> returns some values of the Jn Bessel function.
        </li>
        <li>
          <b>BP01</b> evaluates the N+1 Bernstein basis functions of degree N on [0,1].
        </li>
        <li>
          <b>C8VEC_PRINT_SOME</b> prints some of a C8VEC.
        </li>
        <li>
          <b>C8VEC_UNIFORM_01</b> returns a unit pseudorandom C8VEC.
        </li>
        <li>
          <b>CHFDV</b> evaluates a cubic polynomial and its derivative given in Hermite form.
        </li>
        <li>
          <b>CHFEV</b> evaluates a cubic polynomial given in Hermite form.
        </li>
        <li>
          <b>CHFIV</b> evaluates the integral of a cubic polynomial in Hermite form.
        </li>
        <li>
          <b>CHFMC</b> determines the monotonicity properties of a cubic polynomial.
        </li>
        <li>
          <b>CHKDER</b> checks the gradients of M functions of N variables.
        </li>
        <li>
          <b>CHLHSN</b> finds the L*L' decomposition of the perturbed model hessian matrix.
        </li>
        <li>
          <b>CHOLDC</b> finds the perturbed L*L' decomposition of A+D.
        </li>
        <li>
          <b>COSQB</b> computes the fast cosine transform of quarter wave data.
        </li>
        <li>
          <b>COSQB1</b> is a lower level routine used by COSQB.
        </li>
        <li>
          <b>COSQF</b> computes the fast cosine transform of quarter wave data.
        </li>
        <li>
          <b>COSQF1</b> is a lower level routine used by COSQF.
        </li>
        <li>
          <b>COSQI</b> initializes WSAVE, used in COSQF and COSQB.
        </li>
        <li>
          <b>COST</b> computes the discrete Fourier cosine transform of an even sequence.
        </li>
        <li>
          <b>COSTI</b> initializes WSAVE, used in COST.
        </li>
        <li>
          <b>CSEVL</b> evaluates an N term Chebyshev series.
        </li>
        <li>
          <b>D1FCN</b> is a dummy routine for evaluating the gradient vector.
        </li>
        <li>
          <b>D1MACH</b> returns double precision machine constants.
        </li>
        <li>
          <b>D1MPYQ</b> computes A*Q, where Q is the product of Householder transformations.
        </li>
        <li>
          <b>D2FCN</b> is a dummy version of a routine that computes the second derivative.
        </li>
        <li>
          <b>D9LGMC</b> computes the log gamma correction factor.
        </li>
        <li>
          <b>DAMAX</b> returns the maximum absolute value of the entries in a vector.
        </li>
        <li>
          <b>DASUM</b> takes the sum of the absolute values of a vector.
        </li>
        <li>
          <b>DAXPY</b> computes constant times a vector plus a vector.
        </li>
        <li>
          <b>DDCOR</b> computes corrections to the Y array of DDRIV3.
        </li>
        <li>
          <b>DDCST</b> sets coefficients used by the core integrator DDSTP.
        </li>
        <li>
          <b>DDNTL</b> sets parameters for DDSTP.
        </li>
        <li>
          <b>DDNTP</b> interpolates the K-th derivative of the ODE solution Y at TOUT.
        </li>
        <li>
          <b>DDOT</b> forms the dot product of two vectors.
        </li>
        <li>
          <b>DDPSC</b> computes the predicted YH values.
        </li>
        <li>
          <b>DDPST</b> is called to reevaluate the partial derivatives.
        </li>
        <li>
          <b>DDRIV1</b> solves a system of ordinary differential equations.
        </li>
        <li>
          <b>DDRIV2</b> solves a system of ordinary differential equations.
        </li>
        <li>
          <b>DDRIV3</b> solves a system of ordinary differential equations.
        </li>
        <li>
          <b>DDSCL</b> rescales the YH array whenever the ODE step size is changed.
        </li>
        <li>
          <b>DDSTP</b> performs one step of the integration of an ODE system.
        </li>
        <li>
          <b>DDZRO</b> searches for a zero of a function in a given interval.
        </li>
        <li>
          <b>DFAULT</b> sets default values for the optimization algorithm.
        </li>
        <li>
          <b>DFFTB</b> computes a real periodic sequence from its Fourier coefficients.
        </li>
        <li>
          <b>DFFTB1</b> is a lower level routine used by DFFTB.
        </li>
        <li>
          <b>DFFTF</b> computes the Fourier coefficients of a real periodic sequence.
        </li>
        <li>
          <b>DFFTF1</b> is a lower level routine used by DFFTF and SINT.
        </li>
        <li>
          <b>DFFTI</b> initializes WSAVE, used in DFFTF and DFFTB.
        </li>
        <li>
          <b>DFFTI1</b> is a lower level routine used by DFFTI.
        </li>
        <li>
          <b>DGBFA</b> factors a real band matrix by elimination.
        </li>
        <li>
          <b>DGBSL</b> solves a real banded system factored by DGBCO or DGBFA.
        </li>
        <li>
          <b>DGECO</b> factors a real matrix and estimates its condition number.
        </li>
        <li>
          <b>DGEFA</b> factors a real matrix.
        </li>
        <li>
          <b>DGEFS</b> solves a general N by N system of single precision linear equations.
        </li>
        <li>
          <b>DGESL</b> solves a real general linear system A * X = B.
        </li>
        <li>
          <b>DNOR</b> generates normal random numbers.
        </li>
        <li>
          <b>DSTART</b> is an entry point used to initialize DNOR.
        </li>
        <li>
          <b>DNRM2</b> returns the euclidean norm of a vector.
        </li>
        <li>
          <b>DNSQ</b> finds a zero of a system of N nonlinear functions in N variables.
        </li>
        <li>
          <b>DNSQE</b> is the easy-to-use version of DNSQ.
        </li>
        <li>
          <b>DOGDRV</b> finds the next Newton iterate by the double dogleg method.
        </li>
        <li>
          <b>DOGLEG</b> finds the minimizing combination of Gauss-Newton and gradient steps.
        </li>
        <li>
          <b>DOGSTP</b> finds a new step by the double dogleg algorithm.
        </li>
        <li>
          <b>DQRANK</b> computes the QR factorization of a rectangular matrix.
        </li>
        <li>
          <b>DQRDC</b> computes the QR factorization of a real rectangular matrix.
        </li>
        <li>
          <b>DQRLS</b> solves an linear system in the least squares sense.
        </li>
        <li>
          <b>DQRLSS</b> solves a linear system in a least squares sense.
        </li>
        <li>
          <b>DQRSL</b> computes transformations, projections, and least squares solutions.
        </li>
        <li>
          <b>DROT</b> applies a plane rotation.
        </li>
        <li>
          <b>DROTG</b> constructs a Givens plane rotation.
        </li>
        <li>
          <b>DSCAL</b> scales a vector by a constant.
        </li>
        <li>
          <b>DSFTB</b> computes a "slow" backward Fourier transform of real data.
        </li>
        <li>
          <b>DSFTF</b> computes a "slow" forward Fourier transform of real data.
        </li>
        <li>
          <b>DSVDC</b> computes the singular value decomposition of a real rectangular matrix.
        </li>
        <li>
          <b>DSWAP</b> interchanges two vectors.
        </li>
        <li>
          <b>EA</b> performs extrapolation to accelerate the convergence of a sequence.
        </li>
        <li>
          <b>ENORM</b> computes the Euclidean norm of a vector.
        </li>
        <li>
          <b>ERF_VALUES</b> returns some values of the ERF or "error" function.
        </li>
        <li>
          <b>ERROR_F</b> computes the error function.
        </li>
        <li>
          <b>ERROR_FC</b> computes the complementary error function.
        </li>
        <li>
          <b>EZFFTB</b> computes a real periodic sequence from its Fourier coefficients.
        </li>
        <li>
          <b>EZFFTF</b> computes the Fourier coefficients of a real periodic sequence.
        </li>
        <li>
          <b>EZFFTI</b> initializes WSAVE, used in EZFFTF and EZFFTB.
        </li>
        <li>
          <b>EZFFTI1</b> is a lower level routine used by EZFFTI.
        </li>
        <li>
          <b>FDJAC1</b> estimates an N by N jacobian matrix using forward differences.
        </li>
        <li>
          <b>FMIN</b> seeks a minimizer of a scalar function of a scalar variable.
        </li>
        <li>
          <b>FMIN_RC</b> seeks a minimizer of a scalar function of a scalar variable.
        </li>
        <li>
          <b>FORSLV</b> solves A*x=b where A is lower triangular matrix.
        </li>
        <li>
          <b>FSTOCD</b> approximates the gradient of a function using central differences.
        </li>
        <li>
          <b>FSTOFD</b> approximates a derivative by a first order approximation.
        </li>
        <li>
          <b>FZERO</b> searches for a zero of a function F(X) in a given interval.
        </li>
        <li>
          <b>GAMLIM</b> computes the minimum and maximum bounds for X in GAMMA(X).
        </li>
        <li>
          <b>GAMMA</b> computes the gamma function.
        </li>
        <li>
          <b>GAMMA_VALUES</b> returns some values of the Gamma function.
        </li>
        <li>
          <b>GL15T</b> estimates the integral of a function over a finite interval.
        </li>
        <li>
          <b>GRDCHK</b> checks an analytic gradient against an estimated gradient.
        </li>
        <li>
          <b>HESCHK</b> checks an analytic hessian against a computed estimate.
        </li>
        <li>
          <b>HOOKDR</b> finds the next Newton iterate by the More-Hebdon method.
        </li>
        <li>
          <b>HOOKST</b> finds the new step by the More-Hebdon algorithm.
        </li>
        <li>
          <b>HSNINT</b> provides initial hessian when using secant updates.
        </li>
        <li>
          <b>I1MACH</b> returns integer machine constants.
        </li>
        <li>
          <b>I4_SWAP</b> swaps two integer values.
        </li>
        <li>
          <b>I8_FACTOR</b> factors an integer.
        </li>
        <li>
          <b>IDAMAX</b> finds the index of the vector element of maximum absolute value.
        </li>
        <li>
          <b>INBIN</b> takes a real value X and finds the correct bin for it.
        </li>
        <li>
          <b>INITS</b> estimates the order of an orthogonal series for a given accuracy.
        </li>
        <li>
          <b>J4SAVE</b> saves variables needed by the library error handling routines.
        </li>
        <li>
          <b>JAIRY</b> computes the Airy function and its derivative.
        </li>
        <li>
          <b>LLTSLV</b> solves A*x=b where A = L * L'.
        </li>
        <li>
          <b>LNSRCH</b> finds a next Newton iterate by line search.
        </li>
        <li>
          <b>MVMLTL</b> computes y = L * x where L is a lower triangular matrix stored in A.
        </li>
        <li>
          <b>MVMLTS</b> computes y = A * x where A is a symmetric matrix.
        </li>
        <li>
          <b>MVMLTU</b> computes y = L' * x where L is a lower triangular matrix.
        </li>
        <li>
          <b>NUMXER</b> returns the most recent error number.
        </li>
        <li>
          <b>OPTCHK</b> checks the input to the optimization routine.
        </li>
        <li>
          <b>OPTDRV</b> is a driver for the nonlinear optimization package.
        </li>
        <li>
          <b>OPTIF0</b> provides a simple interface to the minimization package.
        </li>
        <li>
          <b>OPTSTP:</b> unconstrained minimization stopping criteria
        </li>
        <li>
          <b>PASSB</b> is a lower level routine used by CFFTB1.
        </li>
        <li>
          <b>PASSB2</b> is a lower level routine used by CFFTB1.
        </li>
        <li>
          <b>PASSB3</b> is a lower level routine used by CFFTB1.
        </li>
        <li>
          <b>PASSB4</b> is a lower level routine used by CFFTB1.
        </li>
        <li>
          <b>PASSB5</b> is a lower level routine used by CFFTB1.
        </li>
        <li>
          <b>PASSF</b> is a lower level routine used by CFFTF1.
        </li>
        <li>
          <b>PASSF2</b> is a lower level routine used by CFFTF1.
        </li>
        <li>
          <b>PASSF3</b> is a lower level routine used by CFFTF1.
        </li>
        <li>
          <b>PASSF4</b> is a lower level routine used by CFFTF1.
        </li>
        <li>
          <b>PASSF5</b> is a lower level routine used by CFFTF1.
        </li>
        <li>
          <b>PCHCE</b> is called by PCHIC to set end derivatives as requested by the user.
        </li>
        <li>
          <b>PCHCI</b> sets derivatives for a monotone piecewise cubic Hermite interpolant.
        </li>
        <li>
          <b>PCHCS</b> adjusts the curve produced by PCHIM so it is more "visually pleasing".
        </li>
        <li>
          <b>PCHDF</b> approximates a derivative using divided differences of data.
        </li>
        <li>
          <b>PCHEV</b> evaluates a piecewise cubic Hermite or spline function.
        </li>
        <li>
          <b>PCHEZ</b> carries out easy to use spline or cubic Hermite interpolation.
        </li>
        <li>
          <b>PCHFD</b> evaluates a piecewise cubic Hermite function.
        </li>
        <li>
          <b>PCHFE</b> evaluates a piecewise cubic Hermite function at an array of points.
        </li>
        <li>
          <b>PCHIA</b> evaluates the integral of a piecewise cubic Hermite function.
        </li>
        <li>
          <b>PCHIC</b> sets derivatives for a piecewise monotone cubic Hermite interpolant.
        </li>
        <li>
          <b>PCHID</b> evaluates the definite integral of a piecewise cubic Hermite function.
        </li>
        <li>
          <b>PCHIM</b> sets derivatives for a piecewise cubic Hermite interpolant.
        </li>
        <li>
          <b>PCHMC:</b> piecewise cubic Hermite monotonicity checker.
        </li>
        <li>
          <b>PCHQA:</b> easy to use cubic Hermite or spline integration.
        </li>
        <li>
          <b>PCHSP</b> sets derivatives needed for Hermite cubic spline interpolant.
        </li>
        <li>
          <b>PCHST:</b> PCHIP sign-testing routine.
        </li>
        <li>
          <b>PCHSW:</b> the PCHCS switch excursion limiter.
        </li>
        <li>
          <b>Q1DA</b> approximates the definite integral of a function of one variable.
        </li>
        <li>
          <b>Q1DAX</b> approximates the integral of a function of one variable.
        </li>
        <li>
          <b>QAGI</b> approximates an integral over an infinite or semi-infinite interval.
        </li>
        <li>
          <b>QAGIE</b> is called by QAGI to compute integrals on an infinite interval.
        </li>
        <li>
          <b>QFORM</b> produces the explicit QR factorization of a matrix.
        </li>
        <li>
          <b>QK15</b> carries out a 15 point Gauss-Kronrod quadrature rule.
        </li>
        <li>
          <b>QK15I</b> applies a 15 point Gauss Kronrod quadrature rule.
        </li>
        <li>
          <b>QPSRT</b> maintains the descending ordering in a list of integral error estimates.
        </li>
        <li>
          <b>QRAUX1</b> interchanges two rows of an upper Hessenberg matrix.
        </li>
        <li>
          <b>QRAUX2</b> pre-multiplies an upper Hessenberg matrix by a Jacobi rotation.
        </li>
        <li>
          <b>QRFAC</b> computes a QR factorization using Householder transformations.
        </li>
        <li>
          <b>QRUPDT</b> updates a QR factorization.
        </li>
        <li>
          <b>R1MACH</b> returns single precision machine constants.
        </li>
        <li>
          <b>R1UPDT</b> retriangularizes a matrix after a rank one update.
        </li>
        <li>
          <b>R8_SWAP</b> swaps two R8's.
        </li>
        <li>
          <b>R8VEC_PRINT_SOME</b> prints "some" of an R8VEC.
        </li>
        <li>
          <b>R8VEC_REVERSE</b> reverses the elements of an R8VEC.
        </li>
        <li>
          <b>R8VEC_UNIFORM_01</b> returns a unit pseudorandom R8VEC.
        </li>
        <li>
          <b>RADB2</b> is a lower level routine used by RFFTB1.
        </li>
        <li>
          <b>RADB3</b> is a lower level routine used by RFFTB1.
        </li>
        <li>
          <b>RADB4</b> is a lower level routine used by RFFTB1.
        </li>
        <li>
          <b>RADB5</b> is a lower level routine used by RFFTB1.
        </li>
        <li>
          <b>RADBG</b> is a lower level routine used by RFFTB1.
        </li>
        <li>
          <b>RADF2</b> is a lower level routine used by RFFTF1.
        </li>
        <li>
          <b>RADF3</b> is a lower level routine used by RFFTF1.
        </li>
        <li>
          <b>RADF4</b> is a lower level routine used by RFFTF1.
        </li>
        <li>
          <b>RADF5</b> is a lower level routine used by RFFTF1.
        </li>
        <li>
          <b>RADFG</b> is a lower level routine used by RFFTF1.
        </li>
        <li>
          <b>RANDOM_INITIALIZE</b> initializes the FORTRAN 90 random number seed.
        </li>
        <li>
          <b>RESULT</b> prints information about the optimization process.
        </li>
        <li>
          <b>RUNGE</b> evaluates Runge's function.
        </li>
        <li>
          <b>RUNGEP</b> evaluates the derivative of Runge's function.
        </li>
        <li>
          <b>SECFAC</b> updates the hessian by the BFGS factored method.
        </li>
        <li>
          <b>SECUNF</b> updates a Hessian matrix by the BFGS unfactored method.
        </li>
        <li>
          <b>SINQB</b> computes the fast sine transform of quarter wave data.
        </li>
        <li>
          <b>SINQF</b> computes the fast sine transform of quarter wave data.
        </li>
        <li>
          <b>SINQI</b> initializes WSAVE, used in SINQF and SINQB.
        </li>
        <li>
          <b>SINT</b> computes the discrete Fourier sine transform of an odd sequence.
        </li>
        <li>
          <b>SINT1</b> is a lower level routine used by SINT.
        </li>
        <li>
          <b>SINTI</b> initializes WSAVE, used in SINT.
        </li>
        <li>
          <b>SNDOFD</b> approximates a Hessian with a second order finite difference.
        </li>
        <li>
          <b>TIMESTAMP</b> prints the current YMDHMS date as a time stamp.
        </li>
        <li>
          <b>TREGUP</b> decides whether to accept the next optimization iterate.
        </li>
        <li>
          <b>UNCMIN</b> minimizes a smooth nonlinear function of N variables.
        </li>
        <li>
          <b>UNI</b> generates real uniform random numbers on [0,1).
        </li>
        <li>
          <b>USTART</b> is an entry into UNI that allows the user to specify the seed.
        </li>
        <li>
          <b>UNIB</b> ?
        </li>
        <li>
          <b>XERABT</b> aborts program execution and prints an error message.
        </li>
        <li>
          <b>XERCLR</b> resets the current error number to zero.
        </li>
        <li>
          <b>XERCTL</b> allows user control over handling of individual errors.
        </li>
        <li>
          <b>XERDMP</b> prints the error tables and then clears them.
        </li>
        <li>
          <b>XERMAX</b> sets the maximum number of times any error message is to be printed.
        </li>
        <li>
          <b>XERPRT</b> prints a message on each file indicated by xgetua.
        </li>
        <li>
          <b>XERROR</b> processes a diagnostic error message.
        </li>
        <li>
          <b>XERRWV</b> processes an error message that includes numeric information.
        </li>
        <li>
          <b>XERSAV</b> records that an error occurred.
        </li>
        <li>
          <b>XGETF</b> returns current value of error control flag.
        </li>
        <li>
          <b>XGETUA</b> returns the unit number(s) to which error messages are being sent.
        </li>
        <li>
          <b>XGETUN</b> returns the (first) output file to which messages are being sent.
        </li>
        <li>
          <b>XSETF</b> sets the error control flag.
        </li>
        <li>
          <b>XSETUA</b> sets up to 5 unit numbers to which messages are to be sent.
        </li>
        <li>
          <b>XSETUN</b> sets the output file to which error messages are to be sent.
        </li>
        <li>
          <b>ZFFTB</b> computes the backward complex discrete Fourier transform.
        </li>
        <li>
          <b>ZFFTB1</b> is a lower-level routine used by ZFFTB.
        </li>
        <li>
          <b>ZFFTB_2D</b> computes a backward two dimensional complex fast Fourier transform.
        </li>
        <li>
          <b>ZFFTF</b> computes the forward complex discrete Fourier transform.
        </li>
        <li>
          <b>ZFFTF1</b> is a lower level routine used by ZFFTF.
        </li>
        <li>
          <b>ZFFTF_2D</b> computes a two dimensional complex fast Fourier transform.
        </li>
        <li>
          <b>ZFFTI</b> initializes WSAVE, used in ZFFTF and ZFFTB.
        </li>
        <li>
          <b>ZFFTI1</b> is a lower level routine used by ZFFTI.
        </li>
      </ul>
    </p>

    <p>
      You can go up one level to <a href = "../f_src.html">
      the FORTRAN90 source codes</a>.
    </p>

    <hr>

    <i>
      Last revised on 02 April 2008.
    </i>

    <!-- John Burkardt -->

  </body

</html>
