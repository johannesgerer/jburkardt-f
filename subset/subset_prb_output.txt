 9 June 2011   3:46:27.018 PM
 
SUBSET_PRB
  FORTRAN90 version
  Test the SUBSET library.
 
TEST000
  Call RANDOM_INITIALIZE to initialize the
  random number generator.
 
RANDOM_INITIALIZE
  Initialize RANDOM_NUMBER with arbitrary SEED =   1978729035
 
TEST001
  ASM_ENUM returns the number of alternating sign
  matrices of a given order.
 
   0         1
   1         1
   2         2
   3         7
   4        42
   5       429
   6      7436
   7    218348
 
TEST002
  ASM_TRIANGLE returns a row of the alternating sign
  matrix triangle.
 
   0         1
   1         1       1
   2         2       3       2
   3         7      14      14       7
   4        42     105     135     105      42
   5       429    1287    2002    2002    1287     429
   6      7436   26026   47320   56784   47320   26026    7436
   7    218348  873392 1813968 2519400 2519400 1813968  873392  218348
 
TEST003
  BELL computes Bell numbers.
  BELL_VALUES returns some exact values.
 
  N  exact C(I)  computed C(I)
 
     0         1         1
     1         1         1
     2         2         2
     3         5         5
     4        15        15
     5        52        52
     6       203       203
     7       877       877
     8      4140      4140
     9     21147     21147
    10    115975    115975
 
TEST9001
  BVEC_ADD adds binary vectors representing integers;
  BVEC_SUB subtracts binary vectors representing integers;
 
        I        J        K = I + J    L = I - J
 
 
       -57        92
  Directly:                 35      -149
  BVEC_ADD, BVEC_SUB        35      -149
 
        66        12
  Directly:                 78        54
  BVEC_ADD, BVEC_SUB        78        54
 
       -17       -87
  Directly:               -104        70
  BVEC_ADD, BVEC_SUB      -104        70
 
       -49       -78
  Directly:               -127        29
  BVEC_ADD, BVEC_SUB      -127        29
 
       -92        27
  Directly:                -65      -119
  BVEC_ADD, BVEC_SUB       -65      -119
 
       -88       -10
  Directly:                -98       -78
  BVEC_ADD, BVEC_SUB       -98       -78
 
       -20        51
  Directly:                 31       -71
  BVEC_ADD, BVEC_SUB        31       -71
 
        60      -100
  Directly:                -40       160
  BVEC_ADD, BVEC_SUB       -40       160
 
        80       -30
  Directly:                 50       110
  BVEC_ADD, BVEC_SUB        50       110
 
       -81       -98
  Directly:               -179        17
  BVEC_ADD, BVEC_SUB      -179        17
 
TEST9002
  BVEC_COMPLEMENT2 returns the two's complement
  of a (signed) binary vector;
 
 
  I =        -57
  J =         57
 

 
  1111000111
 

 
  0000111001
 
  I =         92
  J =        -92
 

 
  0001011100
 

 
  1110100100
 
  I =         66
  J =        -66
 

 
  0001000010
 

 
  1110111110
 
  I =         12
  J =        -12
 

 
  0000001100
 

 
  1111110100
 
  I =        -17
  J =         17
 

 
  1111101111
 

 
  0000010001
 
TEST9003
  BVEC_MUL multiplies binary vectors 
  representing integers;
 
        I        J        K = I * J
 
 
       -57        92
  Directly:              -5244
  BVEC_MUL               -5244
 
        66        12
  Directly:                792
  BVEC_MUL                 792
 
       -17       -87
  Directly:               1479
  BVEC_MUL                1479
 
       -49       -78
  Directly:               3822
  BVEC_MUL                3822
 
       -92        27
  Directly:              -2484
  BVEC_MUL               -2484
 
       -88       -10
  Directly:                880
  BVEC_MUL                 880
 
       -20        51
  Directly:              -1020
  BVEC_MUL               -1020
 
        60      -100
  Directly:              -6000
  BVEC_MUL               -6000
 
        80       -30
  Directly:              -2400
  BVEC_MUL               -2400
 
       -81       -98
  Directly:               7938
  BVEC_MUL                7938
 
TEST005
  CATALAN computes Catalan numbers.
  CATALAN_VALUES returns some exact values.
 
  N  exact C(I)  computed C(I)
 
     0       1       1
     1       1       1
     2       2       2
     3       5       5
     4      14      14
     5      42      42
     6     132     132
     7     429     429
     8    1430    1430
     9    4862    4862
    10   16796   16796
 
TEST006
  CATALAN_ROW_NEXT computes a row of Catalan's triangle.
 
  First, compute row 7:
   7       1     7    27    75   165   297   429   429
 
  Now compute rows one at a time:
 
   0       1
   1       1     1
   2       1     2     2
   3       1     3     5     5
   4       1     4     9    14    14
   5       1     5    14    28    42    42
   6       1     6    20    48    90   132   132
   7       1     7    27    75   165   297   429   429
   8       1     8    35   110   275   572  1001  1430  1430
   9       1     9    44   154   429  1001  2002  3432  4862  4862
  10       1    10    54   208   637  1638  3640  7072 11934 16796 16796
 
TEST007
  RAT_TO_CFRAC fraction => continued fraction,
  CFRAC_TO_RAT continued fraction => fraction.
 
  Regular fraction is     4096 /    15625
 
  Continued fraction coefficients:
 
       1         0
       2         3
       3         1
       4         4
       5         2
       6         1
       7         1
       8        11
       9        13
 
  The continued fraction convergents.
  The last row contains the value of the continued
  fraction, written as a common fraction.
 
  I, P(I), Q(I), P(I)/Q(I)
 
    1       0       1   0.00000    
    2       1       3  0.333333    
    3       1       4  0.250000    
    4       5      19  0.263158    
    5      11      42  0.261905    
    6      16      61  0.262295    
    7      27     103  0.262136    
    8     313    1194  0.262144    
    9    4096   15625  0.262144    
 
TEST008
  CFRAC_TO_RFRAC: continued fraction to ratio;
  RFRAC_TO_CFRAC: ratio to continued fration.
 
  Rational polynomial fraction coefficients:
 
  P:        1.0000      1.0000      2.0000
  Q:        1.0000      3.0000      1.0000      1.0000
 
  Continued fraction coefficients:
 
       1   1.00000    
       2  0.500000    
       3   1.33333    
       4 -0.500000    
       5  -1.50000    
       6   2.00000    
 
  Recovered rational polynomial:
 
  P:        1.0000      1.0000      2.0000
  Q:        1.0000      3.0000      1.0000      1.0000
 
TEST009
  CHANGE_GREEDY makes change using the biggest
  coins first.
 
  The total for which change is to be made:       73
 
  The available coins are:
 
         1
         5
        10
        25
        50
       100
 
         6      5  3  3  1  1  1
        73     50 10 10  1  1  1
 
TEST010
  CHANGE_NEXT displays the next possible way to make
  change for a given total
 
  The total for which change is to be made:       50
 
 
  The available coins are:
 
         1
         5
        10
        25
        50
       100
 
  1:
   50
 
  2:
   25 25
 
  3:
   25 10 10  5
 
  4:
   25 10 10  1  1  1  1  1
 
  5:
   25 10  5  5  5
 
  6:
   25 10  5  5  1  1  1  1  1
 
  7:
   25 10  5  1  1  1  1  1  1  1  1  1  1
 
  8:
   25 10  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
 
  9:
   25  5  5  5  5  5
 
 10:
   25  5  5  5  5  1  1  1  1  1
 
TEST011
  COMB_NEXT produces combinations.
 
  Combinations of size K =        1
 
    1
    2
    3
    4
    5
 
  Combinations of size K =        2
 
    1  2
    1  3
    1  4
    1  5
    2  3
    2  4
    2  5
    3  4
    3  5
    4  5
 
  Combinations of size K =        3
 
    1  2  3
    1  2  4
    1  2  5
    1  3  4
    1  3  5
    1  4  5
    2  3  4
    2  3  5
    2  4  5
    3  4  5
 
  Combinations of size K =        4
 
    1  2  3  4
    1  2  3  5
    1  2  4  5
    1  3  4  5
    2  3  4  5
 
  Combinations of size K =        5
 
    1  2  3  4  5
 
TEST012
  COMB_ROW computes a row of Pascal's triangle.
 
   0      1
   1      1    1
   2      1    2    1
   3      1    3    3    1
   4      1    4    6    4    1
   5      1    5   10   10    5    1
   6      1    6   15   20   15    6    1
   7      1    7   21   35   35   21    7    1
   8      1    8   28   56   70   56   28    8    1
   9      1    9   36   84  126  126   84   36    9    1
  10      1   10   45  120  210  252  210  120   45   10    1
 
TEST013
  COMB_UNRANK returns a combination of N things
  out of M, given the lexicographic rank.
 
  The total set size is M =       10
  The subset size is N =           5
  The number of combinations of N out of M is      252
 
   Rank	  Combination
 
    1      1   2   3   4   5
    2      1   2   3   4   6
    3      1   2   3   4   7
    6      1   2   3   4  10
    7      1   2   3   5   6
    8      1   2   3   5   7
  250      5   6   8   9  10
  251      5   7   8   9  10
  252      6   7   8   9  10
 
TEST014
  R8_CHOOSE evaluates C(N,K).
 
       N         K    CNK
 
         0         0   1.00000    
         1         0   1.00000    
         1         1   1.00000    
         2         0   1.00000    
         2         1   2.00000    
         2         2   1.00000    
         3         0   1.00000    
         3         1   3.00000    
         3         2   3.00000    
         3         3   1.00000    
         4         0   1.00000    
         4         1   4.00000    
         4         2   6.00000    
         4         3   4.00000    
         4         4   1.00000    
 
TEST015
  I4_CHOOSE evaluates C(N,K).
 
       N       K      CNK
 
         0       0       1
         1       0       1
         1       1       1
         2       0       1
         2       1       2
         2       2       1
         3       0       1
         3       1       3
         3       2       3
         3       3       1
         4       0       1
         4       1       4
         4       2       6
         4       3       4
         4       4       1
 
TEST016
  COMP_NEXT generates compositions.
  COMP_ENUM enumerates compositions.
 
  Seeking all compositions of N =        6
  using        3 parts.
 
  The number of compositions is       28
 
     1     6   0   0
     2     5   1   0
     3     4   2   0
     4     3   3   0
     5     2   4   0
     6     1   5   0
     7     0   6   0
     8     5   0   1
     9     4   1   1
    10     3   2   1
    11     2   3   1
    12     1   4   1
    13     0   5   1
    14     4   0   2
    15     3   1   2
    16     2   2   2
    17     1   3   2
    18     0   4   2
    19     3   0   3
    20     2   1   3
    21     1   2   3
    22     0   3   3
    23     2   0   4
    24     1   1   4
    25     0   2   4
    26     1   0   5
    27     0   1   5
    28     0   0   6
 
TEST017
  COMP_RANDOM generates random compositions.
 
  Seeking random compositions of N =       10
  using        5 parts.
 
     3   3   2   0   2
     2   0   2   2   4
     2   1   5   0   2
     2   1   4   2   1
     1   2   3   1   3
 
TEST0174
  COMPNZ_NEXT generates compositions with nonzero parts.
  COMPNZ_ENUM enumerates them.
 
  Seeking all compositions of N =        6
  using        3 nonzero parts.
 
  The number of these compositions is       10
 
     1     4   1   1
     2     3   2   1
     3     2   3   1
     4     1   4   1
     5     3   1   2
     6     2   2   2
     7     1   3   2
     8     2   1   3
     9     1   2   3
    10     1   1   4
 
TEST0175
  COMPNZ_RANDOM generates random compositions
  with nonzero parts.
 
  Seeking random compositions of N =       10
  using        5 nonzero parts.
 
     1   4   2   1   2
     1   3   1   4   1
     1   1   5   1   2
     3   3   2   1   1
     1   2   3   2   2
 
TEST018
  CONGRUENCE solves a congruence equation:
    A * X = C mod ( B )
 
   I        A         B         C         X     Mod ( A*X-C,B)
 
   1        1027       712         7       269         0
   2        1027       712        -7       443         0
   3        1027      -712         7     -1155         0
   4        1027      -712        -7       443         0
   5       -1027       712         7       443         0
   6       -1027       712        -7       269         0
   7       -1027      -712         7       443         0
   8       -1027      -712        -7     -1155         0
   9           6         8        50         7         0
  10           0         0         0         0         0
  11           0         1         0         0         0
  12           0         1         1         0         0
  13           1         0         0         0         0
  14           1         0         1         1         0
  15           1         1         0         1         0
  16        1024    -15625     11529    -15629         0
  17           0         0         1 Error code =          1
  18           0         3        11 Error code =          2
  19           5         0        19 Error code =          3
  20           2         4         7 Error code =          4
  21           7        19         1        11         0
 
TEST019
  COUNT_POSE_RANDOM poses a random problem for 
  the game "The Count is Good".
 
  Problem #       1
 
    The goal number:
 
           296
 
    The available numbers are 
 
         1   2   3   5   9  50
 
  Problem #       2
 
    The goal number:
 
           817
 
    The available numbers are 
 
         1   2   4   6  50 100
 
  Problem #       3
 
    The goal number:
 
           605
 
    The available numbers are 
 
         3   6   8  25  50  75
 
  Problem #       4
 
    The goal number:
 
           291
 
    The available numbers are 
 
         1   2   7  10  25 100
 
  Problem #       5
 
    The goal number:
 
           944
 
    The available numbers are 
 
         1   2   3   5   8  75
 
TEST020
  R8_TO_CFRAC converts a real number to a
  a sequence of continued fraction convergents.
 
  Use the real number R =    6.28319    
 
             6           6           1   6.00000      0.283185    
             3          19           3   6.33333     -0.501480E-01
             1          25           4   6.25000      0.331853E-01
             1          44           7   6.28571     -0.252898E-02
             7         333          53   6.28302      0.166439E-03
             2         710         113   6.28319     -0.533528E-06
           146      103993       16551   6.28319      0.115578E-08
             3      312689       49766   6.28319     -0.582867E-10
             6     1980127      315147   6.28319      0.547384E-11
             1     2292816      364913   6.28319     -0.322142E-11
             1     4272943      680060   6.28319      0.808242E-12
 
TEST021
  DEBRUIJN computes a de Bruijn string.
 
  The alphabet size is M =        2
  The string length is N =        3
 
    21222111
 
  The alphabet size is M =        3
  The string length is N =        3
 
    212221132131232231332333111
 
  The alphabet size is M =        2
  The string length is N =        4
 
    2121122122221111
 
TEST022
  DEC_ADD adds two decimals.
 
  Number of decimal places is        3
 
  A = 12.8
  B = 4.38
  C = 17.2
 
TEST023
  DEC_DIV divides two decimals.
 
  Number of decimal places is        3
 
  A = 52.3
  B = 13400
  C = 0.0039
 
TEST024
  DEC_MUL multiplies two decimals.
 
  Number of decimal places is        2
 
  A = 0.0014
  B = 1600
  C = 2.2
 
TEST025
  DEC_ROUND "rounds" a decimal to a number of digits.
 
           -----Before-------  -----After--------
  Digits   Mantissa  Exponent  Mantissa  Exponent
 
         1     523      -1           5       1
         2     523      -1          52       0
         3     523      -1         523      -1
         4     523      -1         523      -1
         2    6340       2          63       4
         3    6340       2         634       3
         4    6340       2         634       3
 
TEST026
  RAT_TO_DEC fraction => decimal,
  DEC_TO_RAT decimal => fraction.
 
  In this test, choose the top and bottom
  of a rational at random, and compute the
  equivalent real number.
 
  Then convert to decimal, and the equivalent real.
 
  Then convert back to rational and the equivalent real.
 
   -0.588297=        -563/         957
   -0.588297=  -588296760*10^          -9
   -0.588297=   -14707419/    25000000
 
    1.172598=         659/         562
    1.172598=  1172597864*10^          -9
    1.172598=   146574733/   125000000
 
   -2.522388=        -169/          67
   -2.522388=  -252238805*10^          -8
   -2.522388=   -50447761/    20000000
 
   -4.409091=        -485/         110
   -4.409091=  -440909090*10^          -8
   -4.409091=   -44090909/    10000000
 
   -1.440063=        -913/         634
   -1.440063= -1440063091*10^          -9
   -1.440063= -1440063091/  1000000000
 
   -1.948889=        -877/         450
   -1.948889= -1948888888*10^          -9
   -1.948889=  -243611111/   125000000
 
   -0.260927=        -197/         755
   -0.260927=  -260927152*10^          -9
   -0.260927=   -16307947/    62500000
 
  297.500000=         595/           2
  297.500000=        2975*10^          -1
  297.500000=         595/           2
 
    2.264957=         795/         351
    2.264957=   226495726*10^          -8
    2.264957=   113247863/    50000000
 
  -57.928571=        -811/          14
  -57.928571=  -579285714*10^          -7
  -57.928571=  -289642857/     5000000
 
TEST027
  DEC_TO_S prints a decimal value.
 
  Mantissa  Exponent  String
 
       523        -1  52.3
       134         2  13400
      -134         2  -13400
         0        10  0
    123456        -8  0.00123456
    123456        -7  0.0123456
    123456        -6  0.123456
    123456        -5  1.23456
    123456        -4  12.3456
    123456        -3  123.456
    123456        -2  1234.56
    123456        -1  12345.6
    123456         0  123456
    123456         1  1234560
    123456         2  12345600
    123456         3  123456000
 
TEST028
  DEC_WIDTH determines the "width" of a decimal.
 
  Mantissa  Exponent  Width
 
       523        -1         4
       134         2         5
      -134         2         6
         0        10         1
    123456        -8        10
    123456        -7         9
    123456        -6         8
    123456        -5         7
    123456        -4         7
    123456        -3         7
    123456        -2         7
    123456        -1         7
    123456         0         6
    123456         1         7
    123456         2         8
    123456         3         9
 
TEST029
  DECMAT_DET: determinant of a decimal matrix.
 
 
  The 123/456/789 matrix:
 
       1   2   3
       4   5   6
       7   8   9
 
  Determinant of the 123/456/789 matrix
         0 * 10**        0
 
  The Hilbert matrix:
 
             0.5   0.3333333        0.25         0.2
       0.3333333        0.25         0.2   0.1666667
            0.25         0.2   0.1666667   0.1428571
             0.2   0.1666667   0.1428571       0.125
 
  Determinant of the Hilbert matrix:
         5 * 10 **       -9
 
  The -1,2,-1 matrix:
 
        2   -1    0
       -1    2   -1
        0   -1    2
 
  Determinant of the -1,2,-1 matrix:
         4 * 10 **        0
 
TEST021a
  DERANGE_ENUM counts derangements;
  DERANGE_ENUM2 counts derangements.
  DERANGE_ENUM3 counts derangements.
 
  N    # of derangements
 
         0           1         1         1
         1           0         0         0
         2           1         1         1
         3           2         2         2
         4           9         9         9
         5          44        44        44
         6         265       265       265
         7        1854      1854      1854
         8       14833     14833     14833
         9      133496    133496    133496
        10     1334961   1334961   1334961
 
TEST022a
  DERANGE_BACK_NEXT generates derangements
  using backtracking.
 
  Here, we seek all derangments of order N =        5
 
     1       5   4   2   3   1
     2       5   4   2   1   3
     3       5   4   1   3   2
     4       5   4   1   2   3
     5       5   3   4   2   1
     6       5   3   4   1   2
     7       5   3   2   1   4
     8       5   3   1   2   4
     9       5   1   4   3   2
    10       5   1   4   2   3
    11       5   1   2   3   4
    12       4   5   2   3   1
    13       4   5   2   1   3
    14       4   5   1   3   2
    15       4   5   1   2   3
    16       4   3   5   2   1
    17       4   3   5   1   2
    18       4   3   2   5   1
    19       4   3   1   5   2
    20       4   1   5   3   2
    21       4   1   5   2   3
    22       4   1   2   5   3
    23       3   5   4   2   1
    24       3   5   4   1   2
    25       3   5   2   1   4
    26       3   5   1   2   4
    27       3   4   5   2   1
    28       3   4   5   1   2
    29       3   4   2   5   1
    30       3   4   1   5   2
    31       3   1   5   2   4
    32       3   1   4   5   2
    33       3   1   2   5   4
    34       2   5   4   3   1
    35       2   5   4   1   3
    36       2   5   1   3   4
    37       2   4   5   3   1
    38       2   4   5   1   3
    39       2   4   1   5   3
    40       2   3   5   1   4
    41       2   3   4   5   1
    42       2   3   1   5   4
    43       2   1   5   3   4
    44       2   1   4   5   3
 
TEST023a
  DERANGE_WEED_NEXT generates derangements
  by generating ALL permutations, and "weeding out"
  the ones that are not derangements.
 
  Here, we seek all derangments of order N =        5
 
     1       2   1   4   5   3
     2       2   1   5   3   4
     3       2   3   1   5   4
     4       2   3   4   5   1
     5       2   3   5   1   4
     6       2   4   1   5   3
     7       2   4   5   1   3
     8       2   4   5   3   1
     9       2   5   1   3   4
    10       2   5   4   1   3
    11       2   5   4   3   1
    12       3   1   2   5   4
    13       3   1   4   5   2
    14       3   1   5   2   4
    15       3   4   1   5   2
    16       3   4   2   5   1
    17       3   4   5   1   2
    18       3   4   5   2   1
    19       3   5   1   2   4
    20       3   5   2   1   4
    21       3   5   4   1   2
    22       3   5   4   2   1
    23       4   1   2   5   3
    24       4   1   5   2   3
    25       4   1   5   3   2
    26       4   3   1   5   2
    27       4   3   2   5   1
    28       4   3   5   1   2
    29       4   3   5   2   1
    30       4   5   1   2   3
    31       4   5   1   3   2
    32       4   5   2   1   3
    33       4   5   2   3   1
    34       5   1   2   3   4
    35       5   1   4   2   3
    36       5   1   4   3   2
    37       5   3   1   2   4
    38       5   3   2   1   4
    39       5   3   4   1   2
    40       5   3   4   2   1
    41       5   4   1   2   3
    42       5   4   1   3   2
    43       5   4   2   1   3
    44       5   4   2   3   1
 
TEST024a
  DIGRAPH_ARC_EULER finds an Euler circuit of a digraph.
 
  The arc list of the digraph:
 
       1           2       5
       2           1       4
       3           2       3
       4           1       2
       5           3       1
       6           5       1
       7           4       2
 
  The edge list of the Euler circuit:
 
       1         6
       2         4
       3         3
       4         5
       5         2
       6         7
       7         1
 
  The node list of the Euler circuit:
 
    I  Edge  Node
 
         1       6       1
         2       4       2
         3       3       3
         4       5       1
         5       2       4
         6       7       2
         7       1       5
 
TEST025a
  DIOPHANTINE solves a Diophantine equation:
    A * X + B * Y = C
 
        A         B         C         X     Y     Error
 
        1027       712         7       269      -388         0
        1027       712        -7      -269       388         0
        1027      -712         7       269       388         0
        1027      -712        -7      -269      -388         0
       -1027       712         7      -269      -388         0
       -1027       712        -7       269       388         0
       -1027      -712         7      -269       388         0
       -1027      -712        -7       269      -388         0
           6         8        50         3         4         0
           0         0         0         0         0         0
           0         1         0         0         0         0
           0         1         1         0         1         0
           1         0         0         0         0         0
           1         0         1         1         0         0
           1         1         0         1        -1         0
        1024    -15625     11529        -4        -1         0
           0         0         1 Error code =          1
           0         3        11 Error code =          2
           5         0        19 Error code =          3
           2         4         7 Error code =          4
 
TEST026a
  DIOPHANTINE_SOLUTION_MINIMIZE computes a minimal
  Euclidean norm solution of a Diophantine equation:
    A * X + B * Y = C
 
  Coefficients:
    A =         4096
    B =       -15625
    C =        46116
  Solution:
    X =    665499996
    Y =    174456828
  Residual R = A * X + B * Y - C:
    R =            0
 
  The minimized solution:
    X =           -4
    Y =           -4
  Residual R = A * X + B * Y - C:
    R =            0
 
  The minimal positive solution:
    X =        15621
    Y =         4092
  Residual R = A * X + B * Y - C:
    R =            0
 
TEST026B
  DVEC_ADD adds decimal vectors representing integers;
  DVEC_SUB subtracts decimal vectors representing integers;
 
        I        J        K = I + J    L = I - J
 
 
       -57        92
  Directly:                 35      -149
  DVEC_ADD, DVEC_SUB        35      -149
 
        66        12
  Directly:                 78        54
  DVEC_ADD, DVEC_SUB        78        54
 
       -17       -87
  Directly:               -104        70
  DVEC_ADD, DVEC_SUB      -104        70
 
       -49       -78
  Directly:               -127        29
  DVEC_ADD, DVEC_SUB      -127        29
 
       -92        27
  Directly:                -65      -119
  DVEC_ADD, DVEC_SUB       -65      -119
 
       -88       -10
  Directly:                -98       -78
  DVEC_ADD, DVEC_SUB       -98       -78
 
       -20        51
  Directly:                 31       -71
  DVEC_ADD, DVEC_SUB        31       -71
 
        60      -100
  Directly:                -40       160
  DVEC_ADD, DVEC_SUB       -40       160
 
        80       -30
  Directly:                 50       110
  DVEC_ADD, DVEC_SUB        50       110
 
       -81       -98
  Directly:               -179        17
  DVEC_ADD, DVEC_SUB      -179        17
 
TEST026C
  DVEC_COMPLEMENTX returns the ten's complement
  of a (signed) decimal vector;
 
 
  I =        -57
  J =         57
 

 
  9999999943
 

 
  0000000057
 
  I =         92
  J =        -92
 

 
  0000000092
 

 
  9999999908
 
  I =         66
  J =        -66
 

 
  0000000066
 

 
  9999999934
 
  I =         12
  J =        -12
 

 
  0000000012
 

 
  9999999988
 
  I =        -17
  J =         17
 

 
  9999999983
 

 
  0000000017
 
TEST026D
  DVEC_MUL multiplies decimal vectors 
  representing integers;
 
        I        J        K = I * J
 
 
      -563       913
  Directly:            -514019
  DVEC_MUL             -514019
 
       659       123
  Directly:              81057
  DVEC_MUL               81057
 
      -169      -868
  Directly:             146692
  DVEC_MUL              146692
 
      -485      -780
  Directly:             378300
  DVEC_MUL              378300
 
      -913       268
  Directly:            -244684
  DVEC_MUL             -244684
 
      -877      -101
  Directly:              88577
  DVEC_MUL               88577
 
      -197       510
  Directly:            -100470
  DVEC_MUL             -100470
 
       595      -997
  Directly:            -593215
  DVEC_MUL             -593215
 
       795      -299
  Directly:            -237705
  DVEC_MUL             -237705
 
      -811      -973
  Directly:             789103
  DVEC_MUL              789103
 
  NOW REPEAT THE TEST...
 
  but use too few digits to represent big products.
  This corresponds to an "overflow".
  The result here should get the final decimal
  digits correctly, though.
 
        I        J        K = I * J
 
 
       719       682
  Directly:             490358
  DVEC_MUL               90358
 
      -754      -985
  Directly:             742690
  DVEC_MUL               42690
 
      -480       825
  Directly:            -396000
  DVEC_MUL              -96000
 
      -773      -297
  Directly:             229581
  DVEC_MUL               29581
 
       646      -466
  Directly:            -301036
  DVEC_MUL               -1036
 
       384       123
  Directly:              47232
  DVEC_MUL               47232
 
       723       -92
  Directly:             -66516
  DVEC_MUL              -66516
 
       824       196
  Directly:             161504
  DVEC_MUL               61504
 
      -622       523
  Directly:            -325306
  DVEC_MUL              -25306
 
      -206      -630
  Directly:             129780
  DVEC_MUL               29780
 
TEST027a
  EQUIV_NEXT generates all partitions of a set.
 
  Rank/element:   1   2   3   4
 
     1   1   1   1   1
     2   1   1   1   2
     3   1   1   2   1
     4   1   1   2   2
     5   1   1   2   3
     6   1   2   1   1
     7   1   2   1   2
     8   1   2   1   3
     9   1   2   2   1
    10   1   2   2   2
    11   1   2   2   3
    12   1   2   3   1
    13   1   2   3   2
    14   1   2   3   3
    15   1   2   3   4
 
TEST028a
  EQUIV_NEXT2 generates all partitions of a set.
  Here, N =        4
 
  Rank/element:   1   2   3   4
 
     1             1   1   1   1
     2             1   1   1   2
     3             1   1   2   1
     4             1   1   2   2
     5             1   1   2   3
     6             1   2   1   1
     7             1   2   1   2
     8             1   2   1   3
     9             1   2   2   1
    10             1   2   2   2
    11             1   2   2   3
    12             1   2   3   1
    13             1   2   3   2
    14             1   2   3   3
    15             1   2   3   4
 
TEST029a
  EQUIV_RANDOM selects a random set partition.
 
  The partition:
 
   Set  Size
       1       1 ::    1
       2       3 ::    2   3   4
 
  The partition:
 
   Set  Size
       1       1 ::    4
       2       1 ::    1
       3       1 ::    2
       4       1 ::    3
 
  The partition:
 
   Set  Size
       1       2 ::    1   4
       2       2 ::    2   3
 
  The partition:
 
   Set  Size
       1       2 ::    1   3
       2       1 ::    4
       3       1 ::    2
 
  The partition:
 
   Set  Size
       1       1 ::    3
       2       1 ::    2
       3       2 ::    1   4
 
  Repeat, but print with EQUIV_PRINT2.
 
 
  The partition:
 
( 1)( 2, 3, 4)
 
  The partition:
 
( 4)( 1)( 2)( 3)
 
  The partition:
 
( 1, 4)( 2, 3)
 
  The partition:
 
( 1, 3)( 4)( 2)
 
  The partition:
 
( 3)( 2)( 1, 4)
 
TEST0295
  EULER gets rows of Euler's triangle.
 
        1
        1      0
        1      1      0
        1      4      1      0
        1     11     11      1      0
        1     26     66     26      1      0
        1     57    302    302     57      1      0
        1    120   1191   2416   1191    120      1      0
        1    247   4293  15619  15619   4293    247      1      0
        1    502  14608  88234 156190  88234  14608    502      1      0
 
TEST0304
  FROBENIUS_NUMBER_ORDER2 computes Frobenius numbers of order 2.
  FROBENIUS_NUMBER_ORDER2_VALUES returns some exact values.
 
        C1        C1   exact F  comput F
 
         2         5         3         3
         3        17        31        31
         4        19        23        53
         5        13        47        47
        12        11       109       109
        99       100      9701      9701
 
TEST0305:
  R8_GAMMA_LOG evaluates the logarithm of the 
  Gamma function.
  GAMMA_LOG_VALUES returns some exact values.
 
     X       Exact F       GAMMA_LOG(X)
 
    0.2000   1.524063822       1.524063822    
    0.4000  0.7966778177      0.7966778177    
    0.6000  0.3982338581      0.3982338581    
    0.8000  0.1520596784      0.1520596784    
    1.0000   0.000000000       0.000000000    
    1.1000 -0.4987244126E-01 -0.4987244126E-01
    1.2000 -0.8537409000E-01 -0.8537409000E-01
    1.3000 -0.1081748095     -0.1081748095    
    1.4000 -0.1196129142     -0.1196129142    
    1.5000 -0.1207822376     -0.1207822376    
    1.6000 -0.1125917657     -0.1125917657    
    1.7000 -0.9580769741E-01 -0.9580769741E-01
    1.8000 -0.7108387291E-01 -0.7108387291E-01
    1.9000 -0.3898427592E-01 -0.3898427592E-01
    2.0000   0.000000000       0.000000000    
    3.0000  0.6931471806      0.6931471806    
    4.0000   1.791759469       1.791759469    
   10.0000   12.80182748       12.80182748    
   20.0000   39.33988419       39.33988419    
   30.0000   71.25703897       71.25703897    
 
TEST031
  GRAY_NEXT returns the index of the single item
  to be changed in order to get the next Gray code.
 
   K  Change  Gray Code
 
   0         0  0000
   1         1  1000
   2         2  1100
   3        -1  0100
   4         3  0110
   5         1  1110
   6        -2  1010
   7        -1  0010
   8         4  0011
   9         1  1011
  10         2  1111
  11        -1  0111
  12        -3  0101
  13         1  1101
  14        -2  1001
  15        -1  0001
 
TEST032
  GRAY_RANK ranks a Gray code;
  GRAY_UNRANK unranks a Gray code.
 
    R  =                         RANK
    G  =            GRAY_UNRANK2(RANK)
    R2 = GRAY_RANK2(GRAY_UNRANK2(RANK))
 
         R         G         R2
 
         0         0         0
         1         1         1
         2         3         2
         3         2         3
         4         6         4
         5         7         5
         6         5         6
         7         4         7
         8        12         8
         9        13         9
        10        15        10
        11        14        11
        12        10        12
        13        11        13
        14         9        14
        15         8        15
        16        24        16
        17        25        17
        18        27        18
        19        26        19
        20        30        20
        21        31        21
        22        29        22
        23        28        23
        24        20        24
 
TEST0321
  GRAY_RANK2 ranks a Gray code;
  GRAY_UNRANK2 unranks a Gray code.
 
    R  =                         RANK
    G  =            GRAY_UNRANK2(RANK)
    R2 = GRAY_RANK2(GRAY_UNRANK2(RANK))
 
         R         G         R2
 
         0         0         0
         1         1         1
         2         3         2
         3         2         3
         4         6         4
         5         7         5
         6         5         6
         7         4         7
         8        12         8
         9        13         9
        10        15        10
        11        14        11
        12        10        12
        13        11        13
        14         9        14
        15         8        15
        16        24        16
        17        25        17
        18        27        18
        19        26        19
        20        30        20
        21        31        21
        22        29        22
        23        28        23
        24        20        24
 
TEST0322
  I4_BCLR sets a given bit to 0.
  IBCLR is a FORTRAN90 function which does the same.
 
  Working on I4 =      101
 
       Pos     Digit       I4_BCLR         IBCLR
 
         0         0           100           100
         1         0           101           101
         2         0            97            97
         3         0           101           101
         4         0           101           101
         5         0            69            69
         6         0            37            37
         7         0           101           101
         8         0           101           101
         9         0           101           101
        10         0           101           101
        11         0           101           101
        12         0           101           101
        13         0           101           101
        14         0           101           101
        15         0           101           101
        16         0           101           101
        17         0           101           101
        18         0           101           101
        19         0           101           101
        20         0           101           101
        21         0           101           101
        22         0           101           101
        23         0           101           101
        24         0           101           101
        25         1           101           101
        26         1           101           101
        27         0           101           101
        28         0           101           101
        29         1           101           101
        30         0           101           101
        31         1           101           101
 
  Working on I4 =      -31
 
       Pos     Digit       I4_BCLR         IBCLR
 
         0         1           -32           -32
         1         1           -31           -31
         2         1           -31           -31
         3         1           -31           -31
         4         1           -31           -31
         5         1           -63           -63
         6         1           -95           -95
         7         1          -159          -159
         8         1          -287          -287
         9         1          -543          -543
        10         1         -1055         -1055
        11         1         -2079         -2079
        12         1         -4127         -4127
        13         1         -8223         -8223
        14         1        -16415        -16415
        15         1        -32799        -32799
        16         1        -65567        -65567
        17         1       -131103       -131103
        18         1       -262175       -262175
        19         1       -524319       -524319
        20         1      -1048607      -1048607
        21         1      -2097183      -2097183
        22         1      -4194335      -4194335
        23         1      -8388639      -8388639
        24         1     -16777247     -16777247
        25         1     -33554463     -33554463
        26         1     -67108895     -67108895
        27         0    -134217759    -134217759
        28         0    -268435487    -268435487
        29         0    -536870943    -536870943
        30         0   -1073741855   -1073741855
        31         1    2147483617    2147483617
 
TEST03225
  I4_BSET sets a given bit to 0.
  IBSET is a FORTRAN90 function which does the same.
 
  Working on I4 =      101
 
       Pos     Digit       I4_BSET         IBSET
 
         0         0           101           101
         1         0           103           103
         2         0           101           101
         3         0           109           109
         4         0           117           117
         5         0           101           101
         6         0           101           101
         7         0           229           229
         8         0           357           357
         9         0           613           613
        10         0          1125          1125
        11         0          2149          2149
        12         0          4197          4197
        13         0          8293          8293
        14         0         16485         16485
        15         0         32869         32869
        16         0         65637         65637
        17         0        131173        131173
        18         0        262245        262245
        19         0        524389        524389
        20         0       1048677       1048677
        21         0       2097253       2097253
        22         0       4194405       4194405
        23         0       8388709       8388709
        24         0      16777317      16777317
        25         1      33554533      33554533
        26         1      67108965      67108965
        27         0     134217829     134217829
        28         0     268435557     268435557
        29         1     536871013     536871013
        30         0    1073741925    1073741925
        31         1   -2147483547   -2147483547
 
  Working on I4 =      -31
 
       Pos     Digit       I4_BSET         IBSET
 
         0         1           -31           -31
         1         1           -29           -29
         2         1           -27           -27
         3         1           -23           -23
         4         1           -15           -15
         5         1           -31           -31
         6         1           -31           -31
         7         1           -31           -31
         8         1           -31           -31
         9         1           -31           -31
        10         1           -31           -31
        11         1           -31           -31
        12         1           -31           -31
        13         1           -31           -31
        14         1           -31           -31
        15         1           -31           -31
        16         1           -31           -31
        17         1           -31           -31
        18         1           -31           -31
        19         1           -31           -31
        20         1           -31           -31
        21         1           -31           -31
        22         1           -31           -31
        23         1           -31           -31
        24         1           -31           -31
        25         1           -31           -31
        26         1           -31           -31
        27         0           -31           -31
        28         0           -31           -31
        29         0           -31           -31
        30         0           -31           -31
        31         1           -31           -31
 
TEST0323
  I4_BTEST reports whether a given bit is 0 or 1.
  BTEST is a FORTRAN90 function which does the same.
 
  Analyze the integer I4 =      101
 
       Pos     Digit  I4_BTEST     BTEST
 
         0         0         T         T
         1         0         F         F
         2         0         T         T
         3         0         F         F
         4         0         F         F
         5         0         T         T
         6         0         T         T
         7         0         F         F
         8         0         F         F
         9         0         F         F
        10         0         F         F
        11         0         F         F
        12         0         F         F
        13         0         F         F
        14         0         F         F
        15         0         F         F
        16         0         F         F
        17         0         F         F
        18         0         F         F
        19         0         F         F
        20         0         F         F
        21         0         F         F
        22         0         F         F
        23         0         F         F
        24         0         F         F
        25         1         F         F
        26         1         F         F
        27         0         F         F
        28         0         F         F
        29         1         F         F
        30         0         F         F
        31         1         F         F
 
  Analyze the integer I4 =      -31
 
       Pos     Digit  I4_BTEST     BTEST
 
         0         1         T         T
         1         1         F         F
         2         1         F         F
         3         1         F         F
         4         1         F         F
         5         1         T         T
         6         1         T         T
         7         1         T         T
         8         1         T         T
         9         1         T         T
        10         1         T         T
        11         1         T         T
        12         1         T         T
        13         1         T         T
        14         1         T         T
        15         1         T         T
        16         1         T         T
        17         1         T         T
        18         1         T         T
        19         1         T         T
        20         1         T         T
        21         1         T         T
        22         1         T         T
        23         1         T         T
        24         1         T         T
        25         1         T         T
        26         1         T         T
        27         0         T         T
        28         0         T         T
        29         0         T         T
        30         0         T         T
        31         1         T         T
 
TEST0324
  I4_FACTOR factors an integer,
 
  The integer is     2516
 
  Prime representation:
 
         I  FACTOR(I)  POWER(I)
 
         1       2       2
         2      17       1
         3      37       1
 
TEST0325
  I4_GCD computes the greatest common divisor
  of two integers.
 
         I       J    I4_GCD(I,J)
 
        -1      15       1
        12       9       3
         3       1       1
         0       2       2
        -5      10       5
        -4       7       1
         3      12       3
        11       1       1
        13       6       1
        -4       1       1
        13      13      13
        -3       1       1
         0      14      14
        -3       6       3
        12       5       1
 
TEST0327
  I4_LOG_10: whole part of log base 10,
 
         X        I4_LOG_10
 
         0           0
         1           0
         2           0
         3           0
         9           0
        10           1
        11           1
        99           1
       100           2
       101           2
       999           2
      1000           3
      1001           3
        -1           0
        -2           0
        -3           0
        -9           0
       -10           1
       -11           1
       -99           1
      -101           2
 
TEST058
  I4_PARTITION_CONJ conjugates an integer partition.
 
  Original partition:
 
  14 = 1 * 2 + 1 * 5 + 3 * 1 + 1 * 4
 
  Conjugate partition:
 
  14 = 1 * 6 + 1 * 3 + 2 * 2 + 1 * 1
 
TEST059
  I4_PARTITION_NEXT generates partitions of an integer.
  Here N =        7
 
  7 = 1 * 7
  7 = 1 * 6 + 1 * 1
  7 = 1 * 5 + 1 * 2
  7 = 1 * 5 + 2 * 1
  7 = 1 * 4 + 1 * 3
  7 = 1 * 4 + 1 * 2 + 1 * 1
  7 = 1 * 4 + 3 * 1
  7 = 2 * 3 + 1 * 1
  7 = 1 * 3 + 2 * 2
  7 = 1 * 3 + 1 * 2 + 2 * 1
  7 = 1 * 3 + 4 * 1
  7 = 3 * 2 + 1 * 1
  7 = 2 * 2 + 3 * 1
  7 = 1 * 2 + 5 * 1
  7 = 7 * 1
 
TEST060
  I4_PARTITION_NEXT2 produces partitions of an integer.
 
  7 = 1 * 7
  7 = 1 * 6 + 1 * 1
  7 = 1 * 5 + 1 * 2
  7 = 1 * 5 + 2 * 1
  7 = 1 * 4 + 1 * 3
  7 = 1 * 4 + 1 * 2 + 1 * 1
  7 = 1 * 4 + 3 * 1
  7 = 2 * 3 + 1 * 1
  7 = 1 * 3 + 2 * 2
  7 = 1 * 3 + 1 * 2 + 2 * 1
  7 = 1 * 3 + 4 * 1
  7 = 3 * 2 + 1 * 1
  7 = 2 * 2 + 3 * 1
  7 = 1 * 2 + 5 * 1
  7 = 7 * 1
 
TEST061
  I4_PARTITION_COUNT counts partitions of an integer.
  I4_PARTITION_COUNT_VALUES returns some exact values.
 
   N     Exact     Count
 
     0         1         1
     1         1         1
     2         2         2
     3         3         3
     4         5         5
     5         7         7
     6        11        11
     7        15        15
     8        22        22
     9        30        30
    10        42        42
    11        56        56
    12        77        77
    13       101       101
    14       135       135
    15       176       176
    16       231       231
    17       297       297
    18       385       385
    19       490       490
    20       627       627
 
TEST0615
  I4_PARTITION_COUNT2 counts partitions of an integer.
  I4_PARTITION_COUNT_VALUES returns some exact values.
 
   N     Exact     Count
 
     0         1         1
     1         1         1
     2         2         2
     3         3         3
     4         5         5
     5         7         7
     6        11        11
     7        15        15
     8        22        22
     9        30        30
    10        42        42
    11        56        56
    12        77        77
    13       101       101
    14       135       135
    15       176       176
    16       231       231
    17       297       297
    18       385       385
    19       490       490
    20       627       627
 
TEST062
  I4_PARTITION_RANDOM generates a random partition.
  I4_PARTITION_COUNT2 sets up a partition count table
  needed by I4_PARTITION_RANDOM.
 
 
  The number of partitions of N
 
       N    Number of partitions
 
         1           1
         2           1
         3           2
         4           3
         5           5
         6           7
         7          11
         8          15
 
  8 = 5 * 1 + 1 * 3
  8 = 2 * 1 + 1 * 6
  8 = 4 * 1 + 2 * 2
  8 = 4 * 1 + 1 * 4
  8 = 1 * 1 + 1 * 2 + 1 * 5
 
TEST06225
  I4_PARTITIONS_NEXT produces the next
  nondecreasing partitions of an integer, and
  if necessary, increments the integer to keep on going.
 
   I Sum    Partition
 
   0   0     0 0 0
   1   1     1 0 0
   2   2     2 0 0
   3   2     1 1 0
   4   3     3 0 0
   5   3     2 1 0
   6   3     1 1 1
   7   4     4 0 0
   8   4     3 1 0
   9   4     2 2 0
  10   4     2 1 1
  11   5     5 0 0
  12   5     4 1 0
  13   5     3 2 0
  14   5     3 1 1
  15   5     2 2 1
 
  You can start from any legal partition.
  Here, we restart at ( 2, 1, 0 ).
 
   I Sum    Partition
 
   0   3     2 1 0
   1   3     1 1 1
   2   4     4 0 0
   3   4     3 1 0
   4   4     2 2 0
   5   4     2 1 1
   6   5     5 0 0
   7   5     4 1 0
   8   5     3 2 0
   9   5     3 1 1
  10   5     2 2 1
  11   6     6 0 0
  12   6     5 1 0
  13   6     4 2 0
  14   6     3 3 0
  15   6     4 1 1
 
TEST033
  I4_SQRT computes the square root of an integer.
 
       N  Sqrt(N) Remainder
 
         -5        2        1
         -4        2        0
         -3        1        2
         -2        1        1
         -1        1        0
          0        0        0
          1        1        0
          2        1        1
          3        1        2
          4        2        0
          5        2        1
          6        2        2
          7        2        3
          8        2        4
          9        3        0
         10        3        1
         11        3        2
         12        3        3
         13        3        4
         14        3        5
         15        3        6
         16        4        0
         17        4        1
         18        4        2
         19        4        3
         20        4        4
 
TEST034
  I4_SQRT_CF computes the continued fraction form
  of the square root of an integer.
 
   N  Period  Whole  Repeating Part
 
      1       0      1
      2       1      1    2
      3       2      1    1    2
      4       0      2
      5       1      2    4
      6       2      2    2    4
      7       4      2    1    1    1    4
      8       2      2    1    4
      9       0      3
     10       1      3    6
     11       2      3    3    6
     12       2      3    2    6
     13       5      3    1    1    1    1    6
     14       4      3    1    2    1    6
     15       2      3    1    6
     16       0      4
     17       1      4    8
     18       2      4    4    8
     19       6      4    2    1    3    1    2    8
     20       2      4    2    8
 
TEST0625
  I4_TO_BVEC converts an integer to a 
  signed binary vector;
  BVEC_TO_I4 converts a signed binary vector
  to an integer;
 
  I --> BVEC  -->  I
 
   -3  1111111101   -3
   -2  1111111110   -2
   -1  1111111111   -1
    0  0000000000    0
    1  0000000001    1
    2  0000000010    2
    3  0000000011    3
    4  0000000100    4
    5  0000000101    5
    6  0000000110    6
    7  0000000111    7
    8  0000001000    8
    9  0000001001    9
   10  0000001010   10
 
TEST035
  I4_TO_CHINESE computes the Chinese Remainder
  representation of an integer.
  CHINESE_TO_I4 computes an integer with the given
  Chinese Remainder representation.
 
  The moduli:
 
       1         3
       2         4
       3         5
       4         7
 
  The number being analyzed is       37
 
  The remainders:
 
       1         1
       2         1
       3         2
       4         2
 
  The reconstructed number is       37
 
  The remainders of the reconstructed number are:
 
       1         1
       2         1
       3         2
       4         2
 
TEST0364
  I4_TO_VAN_DER_CORPUT computes the elements 
  of a van der Corput sequence.
 
  I4_TO_I4POLY converts an integer to an integer 
  polynomial in some base, and can be used to mimic
  the van der Corput calculation.
 
 
  BASE =        2
 
         1    0.500000        0.500000    
         2    0.250000        0.250000    
         3    0.750000        0.750000    
         4    0.125000        0.125000    
         5    0.625000        0.625000    
         6    0.375000        0.375000    
         7    0.875000        0.875000    
         8    0.625000E-01    0.625000E-01
         9    0.562500        0.562500    
        10    0.312500        0.312500    
 
  BASE =        3
 
         1    0.333333        0.333333    
         2    0.666667        0.666667    
         3    0.111111        0.111111    
         4    0.444444        0.444444    
         5    0.777778        0.777778    
         6    0.222222        0.222222    
         7    0.555556        0.555556    
         8    0.888889        0.888889    
         9    0.370370E-01    0.370370E-01
        10    0.370370        0.370370    
 
  BASE =        5
 
         1    0.200000        0.200000    
         2    0.400000        0.400000    
         3    0.600000        0.600000    
         4    0.800000        0.800000    
         5    0.400000E-01    0.400000E-01
         6    0.240000        0.240000    
         7    0.440000        0.440000    
         8    0.640000        0.640000    
         9    0.840000        0.840000    
        10    0.800000E-01    0.800000E-01
 
TEST0627
  I4_TO_I4POLY converts an integer to a polynomial
  in a given base;
  I4POLY_TO_I4 evaluates an integer polynomial.
 
       I    BASE  DEGREE  Coefficients
 
     1     2     0             1
     6     2     2             1       1       0
    23     2     4             1       0       1       1       1
    23     3     2             2       1       2
    23     4     2             1       1       3
    23     5     1             4       3
    23     6     1             3       5
    23    23     1             1       0
    23    24     0            23
 
  Now let I4_TO_I4POLY convert I to a polynomial,
  use I4POLY_TO_I4 to evaluate it, and compare.
 
       I    I2
 
         1         1
         6         6
        23        23
        23        23
        23        23
        23        23
        23        23
        23        23
        23        23
 
TEST036
  I4_TO_VAN_DER_CORPUT computes the elements 
  of a van der Corput sequence.
  The sequence depends on the prime numbers used 
  as a base.
 
  Bases:
 
                 2               3               5               7              11
 
    1  0.500000      0.333333      0.200000      0.142857      0.909091E-01
    2  0.250000      0.666667      0.400000      0.285714      0.181818    
    3  0.750000      0.111111      0.600000      0.428571      0.272727    
    4  0.125000      0.444444      0.800000      0.571429      0.363636    
    5  0.625000      0.777778      0.400000E-01  0.714286      0.454545    
    6  0.375000      0.222222      0.240000      0.857143      0.545455    
    7  0.875000      0.555556      0.440000      0.204082E-01  0.636364    
    8  0.625000E-01  0.888889      0.640000      0.163265      0.727273    
    9  0.562500      0.370370E-01  0.840000      0.306122      0.818182    
   10  0.312500      0.370370      0.800000E-01  0.448980      0.909091    
 
TEST0365
  IBSET sets a bit to 1.
 
           I Bit  IBSET(I,BIT)
 
           101   0           101
           101   1           103
           101   2           101
           101   3           109
           101   4           117
           101   5           101
           101   6           101
           101   7           229
           101   8           357
           101   9           613
           101  10          1125
           101  11          2149
           101  12          4197
           101  13          8293
           101  14         16485
           101  15         32869
           101  16         65637
           101  17        131173
           101  18        262245
           101  19        524389
           101  20       1048677
           101  21       2097253
           101  22       4194405
           101  23       8388709
           101  24      16777317
           101  25      33554533
           101  26      67108965
           101  27     134217829
           101  28     268435557
           101  29     536871013
           101  30    1073741925
           101  31   -2147483547
 
TEST037
  I4MAT_01_ROWCOLSUM constructs a 01 matrix with
  given row and column sums.
 
  The rowsum vector:
 
       1         3
       2         2
       3         2
       4         1
       5         1
 
  The columnsum vector:
 
       1         2
       2         2
       3         2
       4         2
       5         1
 
  The rowcolsum matrix:
 
  Col         1      2      3      4      5
  Row
 
       1        1      0      1      0      1
       2        1      0      0      1      0
       3        0      1      0      1      0
       4        0      1      0      0      0
       5        0      0      1      0      0
 
 
TEST038
  I4MAT_01_ROWCOLSUM2 constructs a 01 matrix with
  given row and column sums.
 
  The rowsum vector:
 
       1         2
       2         1
       3         3
       4         1
       5         2
 
  The columnsum vector:
 
       1         2
       2         1
       3         2
       4         2
       5         2
 
  The rowcolsum matrix:
 
  Col         1      2      3      4      5
  Row
 
       1        0      0      1      1      0
       2        0      0      0      1      0
       3        0      1      1      0      1
       4        1      0      0      0      0
       5        1      0      0      0      1
 
 
  Now repeat, with data for which there is not
  a solution.  The program will try its best anyway.
 
  The rowsum vector:
 
       1         1
       2         3
       3         4
       4         1
       5         3
 
  The columnsum vector:
 
       1         1
       2         4
       3         1
       4         5
       5         1
 
  I4MAT_01_ROWCOLSUM2 returned error flag IERROR =        1
  The matrix returned is not an exact solution.
 
  The rowcolsum matrix:
 
  Col         1      2      3      4      5
  Row
 
       1        0      0      0      1      0
       2        0      1      1      1      0
       3        1      1      0      1      1
       4        0      1      0      1     -1
       5        0      1      0      1      1
 
 
TEST039
  I4MAT_01_ROWCOLSUM constructs a 01 matrix with
  given row and column sums.
 
  The rowsum vector R:
 
       1        14
       2        13
       3        14
       4        10
       5        12
       6         2
       7        10
       8         1
       9        10
      10        11
      11         6
      12         2
      13        17
 
  The columnsum vector C:
 
       1         4
       2         4
       3        11
       4        10
       5        10
       6         8
       7         9
       8        10
       9         8
      10         9
      11         3
      12        10
      13         4
      14         7
      15         9
      16         3
      17         3
 
  The rowcolsum matrix:
 
  Col         1      2      3      4      5      6      7      8      9     10
  Row
 
       1        0      1      1      1      1      1      1      1      1      1
       2        1      0      1      1      1      0      1      1      1      1
       3        1      0      1      1      1      1      1      1      0      1
       4        0      0      1      0      1      1      1      1      1      1
       5        1      1      1      1      1      1      1      1      1      1
       6        0      0      0      1      1      0      0      0      0      0
       7        0      0      1      1      0      1      1      1      1      1
       8        0      0      0      1      0      0      0      0      0      0
       9        0      0      1      1      0      1      1      1      1      1
      10        0      1      1      1      1      1      1      1      1      0
      11        0      0      1      0      1      0      0      1      0      1
      12        0      0      1      0      1      0      0      0      0      0
      13        1      1      1      1      1      1      1      1      1      1
 
  Col        11     12     13     14     15     16     17
  Row
 
       1        1      1      1      0      1      1      0
       2        0      1      1      1      1      0      1
       3        0      1      1      1      1      1      1
       4        0      1      0      1      1      0      0
       5        0      1      0      1      0      0      0
       6        0      0      0      0      0      0      0
       7        0      1      0      1      1      0      0
       8        0      0      0      0      0      0      0
       9        0      1      0      1      1      0      0
      10        0      1      0      1      1      0      0
      11        0      1      0      0      1      0      0
      12        0      0      0      0      0      0      0
      13        2      1      1      0      1      1      1
 
 
  Computed row sums
 
       1        14
       2        13
       3        14
       4        10
       5        12
       6         2
       7        10
       8         1
       9        10
      10        11
      11         6
      12         2
      13        17
 
  Computed column sums:
 
       1         4
       2         4
       3        11
       4        10
       5        10
       6         8
       7         9
       8        10
       9         8
      10         9
      11         3
      12        10
      13         4
      14         7
      15         9
      16         3
      17         3
 
TEST040
  I4MAT_U1_INVERSE inverts a unit upper triangular matrix.
 
  The input matrix:
 
  Col         1      2      3      4      5      6
  Row
 
       1        1      1      0      0      0     75
       2        0      1      0      0      0      0
       3        0      0      1      1      0      0
       4        0      0      0      1      0      0
       5        0      0      0      0      1      1
       6        0      0      0      0      0      1
 
 
  The inverse:
 
  Col         1      2      3      4      5      6
  Row
 
       1        1     -1      0      0      0    -75
       2        0      1      0      0      0      0
       3        0      0      1     -1      0      0
       4        0      0      0      1      0      0
       5        0      0      0      0      1     -1
       6        0      0      0      0      0      1
 
 
TEST041
  I4MAT_PERM reorders an integer matrix in place.
  The rows and columns use the same permutation.
 
  The input matrix:
 
  Col         1      2      3      4      5      6      7      8      9
  Row
 
       1       11     12     13     14     15     16     17     18     19
       2       21     22     23     24     25     26     27     28     29
       3       31     32     33     34     35     36     37     38     39
       4       41     42     43     44     45     46     47     48     49
       5       51     52     53     54     55     56     57     58     59
       6       61     62     63     64     65     66     67     68     69
       7       71     72     73     74     75     76     77     78     79
       8       81     82     83     84     85     86     87     88     89
       9       91     92     93     94     95     96     97     98     99
 
 
  The row and column permutation:
 
     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1
 
  The permuted matrix:
 
  Col         1      2      3      4      5      6      7      8      9
  Row
 
       1       99     91     92     98     97     94     95     96     93
       2       19     11     12     18     17     14     15     16     13
       3       29     21     22     28     27     24     25     26     23
       4       89     81     82     88     87     84     85     86     83
       5       79     71     72     78     77     74     75     76     73
       6       49     41     42     48     47     44     45     46     43
       7       59     51     52     58     57     54     55     56     53
       8       69     61     62     68     67     64     65     66     63
       9       39     31     32     38     37     34     35     36     33
 
 
TEST042
  I4MAT_PERM2 reorders an integer matrix in place.
  Rows and columns use different permutations.
 
  The input matrix:
 
  Col         1      2      3      4      5      6      7
  Row
 
       1       11     12     13     14     15     16     17
       2       21     22     23     24     25     26     27
       3       31     32     33     34     35     36     37
       4       41     42     43     44     45     46     47
       5       51     52     53     54     55     56     57
       6       61     62     63     64     65     66     67
       7       71     72     73     74     75     76     77
       8       81     82     83     84     85     86     87
       9       91     92     93     94     95     96     97
 
 
  The row permutation:
 
     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1
 
  The column permutation:
 
     1   2   3   4   5   6   7
     3   4   5   6   7   1   2
 
  The permuted matrix:
 
  Col         1      2      3      4      5      6      7
  Row
 
       1       96     97     91     92     93     94     95
       2       16     17     11     12     13     14     15
       3       26     27     21     22     23     24     25
       4       86     87     81     82     83     84     85
       5       76     77     71     72     73     74     75
       6       46     47     41     42     43     44     45
       7       56     57     51     52     53     54     55
       8       66     67     61     62     63     64     65
       9       36     37     31     32     33     34     35
 
 
TEST047
  TRIANG relabels elements for a partial ordering,
  I4MAT_PERM2 reorders an integer matrix in place.
 
  The input matrix:
 
  Col         1      2      3      4      5      6      7      8      9     10
  Row
 
       1        1      0      0      0      0      0      0      0      0      0
       2        0      1      0      1      0      1      0      1      0      0
       3        1      0      1      1      0      0      0      0      0      0
       4        0      0      0      1      0      0      0      0      0      0
       5        1      1      1      1      1      1      1      1      0      1
       6        0      0      0      1      0      1      0      1      0      0
       7        1      0      1      1      0      1      1      1      0      1
       8        0      0      0      1      0      0      0      1      0      0
       9        0      0      0      0      0      0      0      0      0      0
      10        1      0      1      1      0      0      0      1      0      1
 
 
  The new ordering:
 
     1   2   3   4   5   6   7   8   9  10
     5   6   4   9   1   7   2   8  10   3
 
  The reordered matrix:
 
  Col         1      2      3      4      5      6      7      8      9     10
  Row
 
       1        1      1      1      1      1      1      1      1      1      0
       2        0      1      1      1      1      0      1      1      1      0
       3        0      0      1      1      1      0      0      1      1      0
       4        0      0      0      1      1      0      0      0      1      0
       5        0      0      0      0      1      0      0      0      0      0
       6        0      0      0      0      0      1      1      1      1      0
       7        0      0      0      0      0      0      1      1      1      0
       8        0      0      0      0      0      0      0      1      1      0
       9        0      0      0      0      0      0      0      0      1      0
      10        0      0      0      0      0      0      0      0      0      0
 
 
TEST043
  INDEX_BOX_NEXT_2D produces IJ indices that
  lie on the surface of a box in 2D.
 
  The box has logical dimensions:
     5  3
 
   #    I   J
 
    1  1  1
    2  1  2
    3  1  3
    4  2  1
    5  2  3
    6  3  1
    7  3  3
    8  4  1
    9  4  3
   10  5  1
   11  5  2
   12  5  3
 
TEST044
  INDEX_BOX_NEXT_3D produces IJK indices that
  lie on the surface of a box.
 
  The box has logical dimensions:
     5  3  4
 
     #    I   J   K
 
    1  1  1  1
    2  1  1  2
    3  1  1  3
    4  1  1  4
    5  1  2  1
    6  1  2  2
    7  1  2  3
    8  1  2  4
    9  1  3  1
   10  1  3  2
   11  1  3  3
   12  1  3  4
   13  2  1  1
   14  2  1  2
   15  2  1  3
   16  2  1  4
   17  2  2  1
   18  2  2  4
   19  2  3  1
   20  2  3  2
   21  2  3  3
   22  2  3  4
   23  3  1  1
   24  3  1  2
   25  3  1  3
   26  3  1  4
   27  3  2  1
   28  3  2  4
   29  3  3  1
   30  3  3  2
   31  3  3  3
   32  3  3  4
   33  4  1  1
   34  4  1  2
   35  4  1  3
   36  4  1  4
   37  4  2  1
   38  4  2  4
   39  4  3  1
   40  4  3  2
   41  4  3  3
   42  4  3  4
   43  5  1  1
   44  5  1  2
   45  5  1  3
   46  5  1  4
   47  5  2  1
   48  5  2  2
   49  5  2  3
   50  5  2  4
   51  5  3  1
   52  5  3  2
   53  5  3  3
   54  5  3  4
 
TEST045
  INDEX_BOX2_NEXT_2D produces IJ indices that
  lie on the surface of a box2 in 2D.
 
  The box has half-widths:
     4  3
 
  and has center cell:
    10 20
 
     #    I   J
 
    1  6 17
    2  6 18
    3  6 19
    4  6 20
    5  6 21
    6  6 22
    7  6 23
    8  7 17
    9  7 23
   10  8 17
   11  8 23
   12  9 17
   13  9 23
   14 10 17
   15 10 23
   16 11 17
   17 11 23
   18 12 17
   19 12 23
   20 13 17
   21 13 23
   22 14 17
   23 14 18
   24 14 19
   25 14 20
   26 14 21
   27 14 22
   28 14 23
 
TEST046
  INDEX_BOX2_NEXT_3D produces IJK indices that
  lie on the surface of a box.
 
  The box has half widths:
     5  3  4
 
  and central cell:
    10 20 30
 
  We will only print a PORTION of the data!
 
   #    I   J   K
 
    1  5 17 26
    2  5 17 27
    3  5 17 28
    4  5 17 29
    5  5 17 30
    6  5 17 31
    7  5 17 32
    8  5 17 33
    9  5 17 34
   10  5 18 26
  370 15 23 26
  371 15 23 27
  372 15 23 28
  373 15 23 29
  374 15 23 30
  375 15 23 31
  376 15 23 32
  377 15 23 33
  378 15 23 34
 
TEST048
  INDEX_NEXT0 generates all indices of an
  array of given shape, with
  lower limit 1 and given upper limit.
 
  Number of index entries =        3
  Coordinate maximum HI =          3
 
  Index arrays:
 
     1   1   1
     2   1   1
     3   1   1
     1   2   1
     2   2   1
     3   2   1
     1   3   1
     2   3   1
     3   3   1
     1   1   2
     2   1   2
     3   1   2
     1   2   2
     2   2   2
     3   2   2
     1   3   2
     2   3   2
     3   3   2
     1   1   3
     2   1   3
     3   1   3
     1   2   3
     2   2   3
     3   2   3
     1   3   3
     2   3   3
     3   3   3
 
TEST049
  INDEX_NEXT1 generates all indices of an
  array of given shape, with
  lower limit 1 and given upper limits.
 
  Number of index entries =        3
 
  Coordinate maximum indices:
 
       1         4
       2         2
       3         3
 
  Index arrays:
 
     1   1   1
     2   1   1
     3   1   1
     4   1   1
     1   2   1
     2   2   1
     3   2   1
     4   2   1
     1   1   2
     2   1   2
     3   1   2
     4   1   2
     1   2   2
     2   2   2
     3   2   2
     4   2   2
     1   1   3
     2   1   3
     3   1   3
     4   1   3
     1   2   3
     2   2   3
     3   2   3
     4   2   3
 
TEST050
  INDEX_NEXT2 generates all indices of an
  array of given shape with given
  lower and upper limits.
 
  Number of index entries =        3
 
  Coordinate, Maximum Index
 
         1        10        11
         2        -5        -3
         3         0         1
 
  Index arrays:
 
    10  -5   0
    11  -5   0
    10  -4   0
    11  -4   0
    10  -3   0
    11  -3   0
    10  -5   1
    11  -5   1
    10  -4   1
    11  -4   1
    10  -3   1
    11  -3   1
 
TEST051
  INDEX_RANK0 ranks an index with
  lower limit 1 and given upper limit.
 
  Number of index entries =        3
 
  Coordinate maximum Index =        3
 
 
  The index array:
 
       1         3
       2         1
       3         2
 
  The rank of this object is       12
 
TEST052
  INDEX_RANK1 ranks an index with
  lower limit 1 and given upper limits.
 
  Number of index entries =        3
 
  Coordinate, Maximum Index
 
           1         4
           2         2
           3         3
 
  The index array:
 
       1         4
       2         1
       3         2
 
  The rank of this object is       12
 
TEST053
  INDEX_RANK2 ranks an index with given
  lower and upper limits.
 
  Number of index entries =        3
 
  Coordinate, Minimum index, Maximum Index
 
           1         1        10
           4         2
           2         1        10
           4        11
           3         1        10
           4         6
 
  The index array:
 
       1         1
       2        11
       3         5
 
  The rank of this object is        7
 
TEST054
  INDEX_UNRANK0 unranks a multi-index.
 
  The multi-index has dimension        3
 
  The upper limit is HI =        3
 
  Rank, Multi-Index:
 
    1       1       1       1
    2       2       1       1
    3       3       1       1
    4       1       2       1
    5       2       2       1
    6       3       2       1
    7       1       3       1
    8       2       3       1
    9       3       3       1
   10       1       1       2
   11       2       1       2
   12       3       1       2
   13       1       2       2
   14       2       2       2
   15       3       2       2
   16       1       3       2
   17       2       3       2
   18       3       3       2
   19       1       1       3
   20       2       1       3
   21       3       1       3
   22       1       2       3
   23       2       2       3
   24       3       2       3
   25       1       3       3
   26       2       3       3
   27       3       3       3
 
TEST055
  INDEX_UNRANK1 unranks a multi-index.
 
  The multi-index has dimension        3
 
  The upper limits are:
 
           1         4
           2         2
           3         3
 
  Rank, Multi-Index:
 
    1       1       1       1
    2       2       1       1
    3       3       1       1
    4       4       1       1
    5       1       2       1
    6       2       2       1
    7       3       2       1
    8       4       2       1
    9       1       1       2
   10       2       1       2
   11       3       1       2
   12       4       1       2
   13       1       2       2
   14       2       2       2
   15       3       2       2
   16       4       2       2
   17       1       1       3
   18       2       1       3
   19       3       1       3
   20       4       1       3
   21       1       2       3
   22       2       2       3
   23       3       2       3
   24       4       2       3
 
TEST056
  INDEX_UNRANK2 unranks a multi-index.
 
  The multi-index has dimension        3
 
  The lower and upper limits are:
 
           1         1         2
           2        10        11
           3         4         6
 
  Rank, Multi-Index:
 
    7       1      11       5
 
TEST057
  PERM_INS computes the inversion sequence.
  INS_PERM recovers the permutation.
 
    1  2  3  4  5
    3  5  1  4  2
    0  0  2  1  3
    3  5  1  4  2
 
TEST063
  INVOLUTE_ENUM counts involutions;
 
 
         N    Number   Probability
 
         0         1     1.00000    
         1         1     1.00000    
         2         2     1.00000    
         3         4    0.666667    
         4        10    0.416667    
         5        26    0.216667    
         6        76    0.105556    
         7       232    0.460317E-01
         8       764    0.189484E-01
         9      2620    0.722002E-02
        10      9496    0.261684E-02
 
TEST064
  I4POLY converts between power sum, factorial
  and Taylor forms, and can evaluate a polynomial
 
  All calls have input A as follows
   0   0   0   0   0   1
 
  Option IOPT =       -3
  Output array = 
     0  24 -50  35 -10   1
 
  Option IOPT =       -2
  Output array = 
     0   1  15  25  10   1
 
  Option IOPT =       -1
  X0 =        2
  Value =        0
 
  Option IOPT =        0
  X0 =        2
  Value =       32
 
  Option IOPT =        6
  X0 =        2
  Output array = 
    32  80  80  40  10   1
 
  Option IOPT =        6
  X0 =       -2
  Output array = 
   -32  80 -80  40 -10   1
 
TEST065
  I4POLY_CYCLO computes cyclotomic polynomials.
 
  N =        0
 
 
  The cyclotomic polynomial:
 
  p(x) =         1
 
  N =        1
 
 
  The cyclotomic polynomial:
 
  p(x) =         1 * x
         -       1
 
  N =        2
 
 
  The cyclotomic polynomial:
 
  p(x) =         1 * x
         +       1
 
  N =        3
 
 
  The cyclotomic polynomial:
 
  p(x) =         1 * x ^   2
         +       1 * x
         +       1
 
  N =        4
 
 
  The cyclotomic polynomial:
 
  p(x) =         1 * x ^   2
         +       1
 
  N =        5
 
 
  The cyclotomic polynomial:
 
  p(x) =         1 * x ^   4
         +       1 * x ^   3
         +       1 * x ^   2
         +       1 * x
         +       1
 
  N =        6
 
 
  The cyclotomic polynomial:
 
  p(x) =         1 * x ^   2
         -       1 * x
         +       1
 
  N =        7
 
 
  The cyclotomic polynomial:
 
  p(x) =         1 * x ^   6
         +       1 * x ^   5
         +       1 * x ^   4
         +       1 * x ^   3
         +       1 * x ^   2
         +       1 * x
         +       1
 
  N =        8
 
 
  The cyclotomic polynomial:
 
  p(x) =         1 * x ^   4
         +       1
 
  N =        9
 
 
  The cyclotomic polynomial:
 
  p(x) =         1 * x ^   6
         +       1 * x ^   3
         +       1
 
  N =       10
 
 
  The cyclotomic polynomial:
 
  p(x) =         1 * x ^   4
         -       1 * x ^   3
         +       1 * x ^   2
         -       1 * x
         +       1
 
TEST066
  I4POLY_DIV computes the quotient and
  remainder for polynomial division.
 
 
  The polynomial to be divided, A:
 
  p(x) =         1 * x ^   3
         +       2 * x ^   2
         -       5 * x
         -       6
 
  The divisor polynomial, B:
 
  p(x) =         1 * x
         -       2
 
  The quotient polynomial, Q:
 
  p(x) =         1 * x ^   2
         +       4 * x
         +       3
 
  The remainder polynomial, R:
 
  p(x) =         0
 
  The polynomial to be divided, A:
 
  p(x) =         1 * x ^   4
         +       3 * x ^   3
         +       2 * x ^   2
         +       5 * x
         -       2
 
  The divisor polynomial, B:
 
  p(x) =         1 * x ^   2
         +       1 * x
         -       3
 
  The quotient polynomial, Q:
 
  p(x) =         1 * x ^   2
         +       2 * x
         +       3
 
  The remainder polynomial, R:
 
  p(x) =         8 * x
         +       7
 
TEST067
  I4POLY_MUL multiplies two polynomials.
 
 
  The factor A:
 
  p(x) =         1 * x
         +       1
 
  The factor B:
 
  p(x) = -       1 * x
         +       1
 
  The product C = A*B:
 
  p(x) = -       1 * x ^   2
         +       1
 
  The factor A:
 
  p(x) =         3 * x ^   2
         +       2 * x
         +       1
 
  The factor B:
 
  p(x) = -       2 * x
         +       1
 
  The product C = A*B:
 
  p(x) = -       6 * x ^   3
         -       1 * x ^   2
         +       1
 
TEST0675
  I4VEC_DESCENDS is true if an integer vector decreases.
 
 
  The integer array to search:
 
       1         1
       2         4
       3         4
       4         3
  The preceding vector is not descending.
 
  The integer array to search:
 
       1         2
       2         1
       3         2
       4         1
  The preceding vector is not descending.
 
  The integer array to search:
 
       1         1
       2         3
       3         1
       4         2
  The preceding vector is not descending.
 
  The integer array to search:
 
       1         2
       2         4
       3         4
       4         1
  The preceding vector is not descending.
 
  The integer array to search:
 
       1         4
       2         2
       3         1
       4         1
  The preceding vector is descending.
 
TEST068
  I4VEC_FRAC: K-th smallest integer vector entry.
 
 
  The integer array to search:
 
       1         5
       2        20
       3        17
       4        12
       5         9
       6         2
       7         6
       8         3
       9         1
      10        13
 
       K       K-th smallest
 
         1         1
         2         2
         3         3
         4         5
         5         6
         6         9
         7        12
         8        13
         9        17
        10        20
 
TEST0683
  I4VEC_INDEX returns the index of the first occurrence
  of a given value in an integer vector.
 
 
  The integer array to search:
 
       1         3
       2        10
       3         9
       4         6
       5         5
       6         1
       7         3
       8         2
       9         1
      10         7
      11         1
      12         5
      13         5
      14         8
      15         8
      16         1
      17         9
      18         4
      19         1
      20         1
 
  The value searched for is        7
  The index of first occurrence is       10
 
TEST0685
  I4VEC_MAXLOC_LAST: index of the last maximal
  entry in an integer vector.
 
 
  The integer array to search:
 
       1         2
       2         5
       3         5
       4         3
       5         3
       6         1
       7         2
       8         1
       9         1
      10         4
      11         1
      12         3
      13         3
      14         4
      15         4
      16         1
      17         5
      18         2
      19         1
      20         1
 
  Index of last maximal entry is       17
 
TEST0686
  I4VEC_PAIRWISE_PRIME is true if an integer vector
  is pairwise prime.
 
 
  The integer array to check:
 
       1         1
       2         4
       3         4
       4         3
  The preceding vector is not pairwise prime.
 
  The integer array to check:
 
       1         2
       2         1
       3         2
       4         1
  The preceding vector is not pairwise prime.
 
  The integer array to check:
 
       1         1
       2         3
       3         1
       4         2
  The preceding vector is pairwise prime.
 
  The integer array to check:
 
       1         2
       2         4
       3         4
       4         1
  The preceding vector is not pairwise prime.
 
  The integer array to check:
 
       1         4
       2         2
       3         1
       4         1
  The preceding vector is not pairwise prime.
 
TEST0687
  I4VEC_REVERSE reverses an integer vector.
 
 
  The integer array:
 
       1         2
       2         5
       3         5
       4         3
       5         3
 
  The reversed integer array:
 
       1         3
       2         3
       3         5
       4         5
       5         2
 
TEST0688
  I4VEC_SORT_BUBBLE_A ascending sorts an integer vector
  using bubble sort.
 
 
  Unsorted array:
 
       1        13
       2        58
       3        50
       4        34
       5        25
       6         4
       7        15
       8         6
       9         2
      10        38
      11         3
      12        27
      13        24
      14        46
      15        48
      16         0
      17        54
      18        21
      19         5
      20         0
 
  Sorted array:
 
       1         0
       2         0
       3         2
       4         3
       5         4
       6         5
       7         6
       8        13
       9        15
      10        21
      11        24
      12        25
      13        27
      14        34
      15        38
      16        46
      17        48
      18        50
      19        54
      20        58
 
TEST0689
  I4VEC_SORT_HEAP_INDEX_D descending index-sorts
  an integer vector using heap sort.
 
 
  Unsorted array:
 
       1        13
       2        58
       3        50
       4        34
       5        25
       6         4
       7        15
       8         6
       9         2
      10        38
      11         3
      12        27
      13        24
      14        46
      15        48
      16         0
      17        54
      18        21
      19         5
      20         0
 
       I    INDX    A(INDX)
 
         1       2      58
         2      17      54
         3       3      50
         4      15      48
         5      14      46
         6      10      38
         7       4      34
         8      12      27
         9       5      25
        10      13      24
        11      18      21
        12       7      15
        13       1      13
        14       8       6
        15      19       5
        16       6       4
        17      11       3
        18       9       2
        19      20       0
        20      16       0
 
TEST06895
  INVERSE_MOD_N seeks Y, the inverse of B mod N,
  so that mod ( B * Y, N ) = 1, but returns 0
  if the inverse does not exist.
 
     B     N     Y     Z = mod ( B * Y, N )
 
     1     2     1     1
     1     3     1     1
     2     3     2     1
     1     4     1     1
     2     4     0     0
     3     4     3     1
     1     5     1     1
     2     5     3     1
     3     5     2     1
     4     5     4     1
     1     6     1     1
     2     6     0     0
     3     6     0     0
     4     6     0     0
     5     6     5     1
     1     7     1     1
     2     7     4     1
     3     7     5     1
     4     7     2     1
     5     7     3     1
     6     7     6     1
     1     8     1     1
     2     8     0     0
     3     8     3     1
     4     8     0     0
     5     8     5     1
     6     8     0     0
     7     8     7     1
     1     9     1     1
     2     9     5     1
     3     9     0     0
     4     9     7     1
     5     9     2     1
     6     9     0     0
     7     9     4     1
     8     9     8     1
     1    10     1     1
     2    10     0     0
     3    10     7     1
     4    10     0     0
     5    10     0     0
     6    10     0     0
     7    10     3     1
     8    10     0     0
     9    10     9     1
 
TEST0695
  RFRAC_TO_JFRAC converts a rational polynomial
  fraction to a J fraction.
  JFRAC_TO_RFRAC converts a J fraction
  to a rational polynomial fraction.
 
  The original rational polynomial coefficients:
 
    0.218418      0.956318      0.829509      0.561695      0.415307    
    0.661187E-01
    0.641848      0.273997      0.109216       1.57976      0.153816    
     1.12019       1.00000    
 
  The J fraction coefficients:
 
    0.661187E-01   24.0763     -0.310636       1.40276       5.16789    
   -0.686133E-01
    -5.16104       4.91564     -0.945630      -1.04001       2.91888    
    0.432351    
 
  The recovered rational polynomial:
 
    0.218418      0.956318      0.829509      0.561695      0.415307    
    0.661187E-01
    0.641848      0.273997      0.109216       1.57976      0.153816    
     1.12019       1.00000    
 
TEST070
  JOSEPHUS solves Josephus problems.
 
    N    M    K	 X
 
     41    3   41   31
     41  -38   41   31
     41    3   40   16
     64    2   64    1
   1000    2 1000  977
 
TEST071
  KSUB_NEXT generates all K subsets of an N set
  in lexicographic order.
 
     1       1   2   3
     2       1   2   4
     3       1   2   5
     4       1   3   4
     5       1   3   5
     6       1   4   5
     7       2   3   4
     8       2   3   5
     9       2   4   5
    10       3   4   5
 
TEST072
  KSUB_NEXT2 generates the next K subset of an
  N set by the revolving door method.
 
  Rank  Subset  Added  Removed
 
     1   1 2 3    0        0
     2   1 3 4    4        2
     3   2 3 4    2        1
     4   1 2 4    1        3
     5   1 4 5    5        2
     6   2 4 5    2        1
     7   3 4 5    3        2
     8   1 3 5    1        4
     9   2 3 5    2        1
    10   1 2 5    1        3
 
TEST073
  KSUB_NEXT3 generates all K subsets of an N set
  using the revolving door method.
 
  Rank    Subset  Added Removed
 
     1   1 2 3    0        0
     2   1 3 4    4        2
     3   2 3 4    2        1
     4   1 2 4    1        3
     5   1 4 5    5        2
     6   2 4 5    2        1
     7   3 4 5    3        2
     8   1 3 5    1        4
     9   2 3 5    2        1
    10   1 2 5    1        3
 
TEST074
  KSUB_NEXT4 generates K subsets of an N set.
  N =        5
  K=         3
 
  Rank    Subset
 
     1       1   2   3
     2       1   2   4
     3       1   3   4
     4       2   3   4
     5       1   2   5
     6       1   3   5
     7       2   3   5
     8       1   4   5
     9       2   4   5
    10       3   4   5
 
TEST075
  KSUB_RANDOM generates a random K subset of an N set.
  Set size is N =           5
  Subset size is K =        3
 
    2  4  5
    1  2  4
    1  4  5
    1  4  5
    1  3  4
 
TEST076
  KSUB_RANDOM2 generates a random K subset of an N set.
  Set size is N =           5
  Subset size is K =        3
 
    1  4  5
    1  2  3
    1  3  4
    1  4  5
    1  2  3
 
TEST077
  KSUB_RANDOM3 generates a random K-subset of an N-set.
  Set size is N =           5
  Subset size is K =        3
 
    1  0  0  1  1
    1  1  0  1  0
    1  0  0  1  1
    1  1  1  0  0
    0  1  0  1  1
    1  1  0  1  0
    1  0  0  1  1
    1  0  1  0  1
    1  0  0  1  1
    0  1  0  1  1
 
TEST0771
  KSUB_RANDOM4 generates a random K subset of an N set.
  Set size is N =           5
  Subset size is K =        3
 
    1  2  4
    5  4  3
    4  2  3
    1  4  5
    1  2  5
 
TEST07715
  KSUB_RANDOM5 generates a random K subset of an N set.
  Set size is N =          52
  Subset size is K =        5
 
   12 24 31 44 50
    4  6  8 15 35
    4 23 24 40 43
    1  5  8 20 47
    4  9 17 44 45
 
TEST0772
  KSUB_RANK: rank of a K subset of an N set.
 
  For N =        5
  and K =        3
  the subset is:
   1   3   5
 
  The rank is        6
 
TEST0773
  KSUB_UNRANK: find the K-subset of an N set
  of a given rank.
 
  N is        5
  K is        3
  and the desired rank is        8
 
  The subset of the given rank is:
     1   4   5
 
TEST078
  MATRIX_PRODUCT_OPT seeks the optimal order
  for a chain of matrix products.
 
  Matrix ranks:
 
         I         R         C
 
         1         4         2
         2         2         3
         3         3         1
         4         1         2
         5         2         2
         6         2         3
 
  Optimal cost is       36
 
  Ordering:
 
       1         2
       2         1
       3         4
       4         5
       5         3
 
TEST079
  MOEBIUS_MATRIX computes the Moebius matrix.
 
  The input matrix:
 
  Col         1      2      3      4      5      6      7      8      9     10
  Row
 
       1        0      0      0      0      0      1      0      0      0      1
       2        0      0      1      1      0      0      0      0      0      0
       3        1      0      0      0      0      0      0      0      1      0
       4        1      0      0      0      1      0      0      0      1      0
       5        0      0      0      0      0      1      0      0      0      0
       6        0      0      0      0      0      0      1      0      0      0
       7        0      0      0      0      0      0      0      0      0      0
       8        0      1      0      0      0      0      0      0      0      0
       9        0      0      0      0      0      1      0      0      0      1
      10        0      0      0      0      0      0      1      0      0      0
      11        0      0      0      0      0      0      1      0      0      0
 
  Col        11
  Row
 
       1        0
       2        0
       3        0
       4        0
       5        0
       6        0
       7        0
       8        0
       9        1
      10        0
      11        0
 
 
  The Moebius matrix:
 
  Col         1      2      3      4      5      6      7      8      9     10
  Row
 
       1        1      0      0      0      0     -1      1      0      0     -1
       2        1      1     -1     -1      0     -1      1      0      1     -1
       3       -1      0      1      0      0      1     -1      0     -1      1
       4       -1      0      0      1     -1      2     -1      0     -1      1
       5        0      0      0      0      1     -1      0      0      0      0
       6        0      0      0      0      0      1     -1      0      0      0
       7        0      0      0      0      0      0      1      0      0      0
       8        0     -1      0      0      0      0      0      1      0      0
       9        0      0      0      0      0     -1      2      0      1     -1
      10        0      0      0      0      0      0     -1      0      0      1
      11        0      0      0      0      0      0     -1      0      0      0
 
  Col        11
  Row
 
       1        0
       2        0
       3        0
       4        0
       5        0
       6        0
       7        0
       8        0
       9       -1
      10        0
      11        1
 
 
TEST0795
  MONOMIAL_COUNT counts the number of monomials of
  degrees 0 through DEGREE_MAX in a space of dimension DIM.
  MONOMIAL_COUNTS provides individual counts.
 
  DIM =        1
 
         0         1
         1         1
         2         1
         3         1
         4         1
         5         1
         6         1
         7         1
         8         1
         9         1
 
     Total        10        10
 
  DIM =        2
 
         0         1
         1         2
         2         3
         3         4
         4         5
         5         6
         6         7
         7         8
         8         9
         9        10
 
     Total        55        55
 
  DIM =        3
 
         0         1
         1         3
         2         6
         3        10
         4        15
         5        21
         6        28
         7        36
         8        45
         9        55
 
     Total       220       220
 
  DIM =        4
 
         0         1
         1         4
         2        10
         3        20
         4        35
         5        56
         6        84
         7       120
         8       165
         9       220
 
     Total       715       715
 
  DIM =        5
 
         0         1
         1         5
         2        15
         3        35
         4        70
         5       126
         6       210
         7       330
         8       495
         9       715
 
     Total      2002      2002
 
  DIM =        6
 
         0         1
         1         6
         2        21
         3        56
         4       126
         5       252
         6       462
         7       792
         8      1287
         9      2002
 
     Total      5005      5005
 
TEST080
  MORSE_THUE computes the Morse-Thue numbers.
 
    0110100110
    0101101001
    0110011010
    0110010110
    0110100101
    1010011001
    0110100101
    1001101001
    0110100110
    0101100110
    1
 
TEST081
  MULTINOMIAL_COEF1 computes multinomial
  coefficients using the Gamma function;
  MULTINOMIAL_COEF2 computes multinomial
  coefficients directly.
 
  Line 10 of the BINOMIAL table:
 
     0  10       1    1
     1   9      10   10
     2   8      45   45
     3   7     120  120
     4   6     210  210
     5   5     252  252
     6   4     210  210
     7   3     120  120
     8   2      45   45
     9   1      10   10
    10   0       1    1
 
  Level 5 of the TRINOMIAL coefficients:
 
     0   0   5       1    1
     0   1   4       5    5
     0   2   3      10   10
     0   3   2      10   10
     0   4   1       5    5
     0   5   0       1    1
 
     1   0   4       5    5
     1   1   3      20   20
     1   2   2      30   30
     1   3   1      20   20
     1   4   0       5    5
 
     2   0   3      10   10
     2   1   2      30   30
     2   2   1      30   30
     2   3   0      10   10
 
     3   0   2      10   10
     3   1   1      20   20
     3   2   0      10   10
 
     4   0   1       5    5
     4   1   0       5    5
 
     5   0   0       1    1
 
TEST0813
  MULTIPERM_ENUM enumerates multipermutations.
 
  N is the number of objects to be permuted.
  K is the number of distinct types of objects.
  COUNTS is the number of objects of each type.
  NUMBER is the number of multipermutations.
 
  Number       N       K       Counts(1:K)
 
       5       5       2     4     1
      20       5       3     1     1     3
      60       5       4     1     1     2     1
       5       5       2     1     4
     120       5       5     1     1     1     1     1
 
TEST0815
  MULTIPERM_NEXT computes multipermutations in
  lexical order.
 
     1     1   2   2   3   3   3
     2     1   2   3   2   3   3
     3     1   2   3   3   2   3
     4     1   2   3   3   3   2
     5     1   3   2   2   3   3
     6     1   3   2   3   2   3
     7     1   3   2   3   3   2
     8     1   3   3   2   2   3
     9     1   3   3   2   3   2
    10     1   3   3   3   2   2
    11     2   1   2   3   3   3
    12     2   1   3   2   3   3
    13     2   1   3   3   2   3
    14     2   1   3   3   3   2
    15     2   2   1   3   3   3
    16     2   2   3   1   3   3
    17     2   2   3   3   1   3
    18     2   2   3   3   3   1
    19     2   3   1   2   3   3
    20     2   3   1   3   2   3
    21     2   3   1   3   3   2
    22     2   3   2   1   3   3
    23     2   3   2   3   1   3
    24     2   3   2   3   3   1
    25     2   3   3   1   2   3
    26     2   3   3   1   3   2
    27     2   3   3   2   1   3
    28     2   3   3   2   3   1
    29     2   3   3   3   1   2
    30     2   3   3   3   2   1
    31     3   1   2   2   3   3
    32     3   1   2   3   2   3
    33     3   1   2   3   3   2
    34     3   1   3   2   2   3
    35     3   1   3   2   3   2
    36     3   1   3   3   2   2
    37     3   2   1   2   3   3
    38     3   2   1   3   2   3
    39     3   2   1   3   3   2
    40     3   2   2   1   3   3
    41     3   2   2   3   1   3
    42     3   2   2   3   3   1
    43     3   2   3   1   2   3
    44     3   2   3   1   3   2
    45     3   2   3   2   1   3
    46     3   2   3   2   3   1
    47     3   2   3   3   1   2
    48     3   2   3   3   2   1
    49     3   3   1   2   2   3
    50     3   3   1   2   3   2
    51     3   3   1   3   2   2
    52     3   3   2   1   2   3
    53     3   3   2   1   3   2
    54     3   3   2   2   1   3
    55     3   3   2   2   3   1
    56     3   3   2   3   1   2
    57     3   3   2   3   2   1
    58     3   3   3   1   2   2
    59     3   3   3   2   1   2
    60     3   3   3   2   2   1
 
TEST082
  NETWORK_FLOW_MAX finds the maximum flow on a network.
 
  The source is node        1
  The sink is node          6
 
  Endpoint array:
 
    1  1  2  2  2  3  3  4  4  5  2  3  3  4  5  4  5  5  6  6
    2  3  3  4  5  4  5  5  6  6  1  1  2  2  2  3  3  4  4  5
 
  Input edge capacity array:
 
    3  7  2  5  4  1  4  2  8  3  0  0  0  0  0  0  0  0  0  0
 
  Reordered endpoint array:
 
    1  1  2  2  2  2  3  3  3  3  4  4  4  4  5  5  5  5  6  6
    2  3  1  3  4  5  1  2  4  5  2  3  5  6  2  3  4  6  4  5
 
  Output edge capacity/flow array:
 
    3  7  0  2  5  4  0  0  1  4  0  0  2  8  0  0  0  3  0  0
    3  4 -3  0  3  0 -4  0  1  3 -3 -1  0  4  0 -3  0  3 -4 -3
 
  Minimal node cut vector:
 
       1         1
       2         0
       3         1
       4         0
       5         1
       6         0
 
  Nodal flow vector:
 
       1         7
       2         3
       3         4
       4         4
       5         3
       6         7
 
TEST083
  NIM_SUM computes the Nim sum of two integers.
 
    I    J    Nim(I+J)
 
 
  I1, I2, I3 in decimal:
 
  218
  957
  871
 
  I1, I2, I3 in binary:
 
 

 
  00000000000000000000000011011010
 

 
  00000000000000000000001110111101
 

 
  00000000000000000000001101100111
 
  I1, I2, I3 in decimal:
 
  830
  562
  268
 
  I1, I2, I3 in binary:
 
 

 
  00000000000000000000001100111110
 

 
  00000000000000000000001000110010
 

 
  00000000000000000000000100001100
 
  I1, I2, I3 in decimal:
 
  415
   66
  477
 
  I1, I2, I3 in binary:
 
 

 
  00000000000000000000000110011111
 

 
  00000000000000000000000001000010
 

 
  00000000000000000000000111011101
 
  I1, I2, I3 in decimal:
 
  257
  110
  367
 
  I1, I2, I3 in binary:
 
 

 
  00000000000000000000000100000001
 

 
  00000000000000000000000001101110
 

 
  00000000000000000000000101101111
 
  I1, I2, I3 in decimal:
 
   43
  634
  593
 
  I1, I2, I3 in binary:
 
 

 
  00000000000000000000000000101011
 

 
  00000000000000000000001001111010
 

 
  00000000000000000000001001010001
 
TEST0835
  PADOVAN computes the Padovan numbers.
 
 
       N        P(N)
 
         0           1
         1           1
         2           1
         3           2
         4           2
         5           3
         6           4
         7           5
         8           7
         9           9
        10          12
        11          16
        12          21
        13          28
        14          37
 
TEST084
  PELL_BASIC solves the basic Pell equation.
  PELL_NEXT computes the "next" solution.
 
       D       X        Y         R
 
          2        3        2        1
                  17       12        1
          3        2        1        1
                   7        4        1
          5        9        4        1
                 161       72        1
          6        5        2        1
                  49       20        1
          7        8        3        1
                 127       48        1
          8        3        1        1
                  17        6        1
         10       19        6        1
                 721      228        1
         11       10        3        1
                 199       60        1
         12        7        2        1
                  97       28        1
         13      649      180        1
              842401   233640        1
         14       15        4        1
                 449      120        1
         15        4        1        1
                  31        8        1
         17       33        8        1
                2177      528        1
         18       17        4        1
                 577      136        1
         19      170       39        1
               57799    13260        1
         20        9        2        1
                 161       36        1
 
TEST085
  PENT_ENUM counts points in pentagons.
 
 
  N    Pent(N)
 
           0         0
           1         1
           2         5
           3        12
           4        22
           5        35
           6        51
           7        70
           8        92
           9       117
          10       145
 
TEST093
  PERM_ASCEND determines the length of the longest
  increasing subsequence in a permutation.
 
  The permutation:
 
     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1
 
  The length of the longest increasing subsequence is        5
 
  A longest increasing subsequence:
 
       1         2
       2         3
       3         6
       4         7
       5         8
 
TEST086
  PERM_BREAK_COUNT counts the breaks in a permutation.
 
  The permutation:
 
     1   2   3   4   5   6
     4   5   2   1   6   3
 
  The number of breaks is        5
 
TEST087
  PERM_CANON_TO_CYCLE converts a permutation from
  canonical to cycle form.
 
  The permutation in canonical form:
 
     1   2   3   4   5   6
     4   5   2   1   6   3
 
  The permutation in cycle form:
 
     1   2   3   4   5   6
    -4   5  -2  -1   6   3
 
TEST088
  PERM_CYCLE analyzes a permutation.
 
  The permutation:
 
     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1
 
  NCYCLE =        3
  ISGN =          1
 
  The permutation in cycle form:
 
     1   2   3   4   5   6   7   8   9
    -2   3   9  -6  -7   8   5   4   1
 
TEST089
  PERM_CYCLE_TO_CANON converts a permutation from
  cycle to canonical form.
 
  The permutation in cycle form:
 
     1   2   3   4   5   6
    -6   3   1  -5   4  -2
 
  The permutation in canonical form:
 
     1   2   3   4   5   6
     4   5   2   1   6   3
 
TEST090
  PERM_CYCLE_TO_INDEX converts a permutation from
  cycle to standard index form.
  PERM_INDEX_TO_CYCLE converts a permutation from
  standard index to cycle form.
 
  The standard index form permutation:
 
     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1
 
  The permutation in cycle form:
 
     1   2   3   4   5   6   7   8   9
    -1   2   3   9  -4   6   8  -5   7
 
  The standard index form permutation:
 
     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1
 
TEST091
  PERM_DISTANCE computes the Ulam metric distance
  between two permutations.
 
  Permutation P1
 
     1   2   3   4   5   6   7   8   9  10
     4   3   2  10   1   7   9   6   8   5
 
  Permutation P2
 
     1   2   3   4   5   6   7   8   9  10
     9   3   5   7   8   6   1   4  10   2
 
  Permutation P3
 
     1   2   3   4   5   6   7   8   9  10
     2   4   1   3   8   6   9   7  10   5
 
  K(P1,P1) should be 0.
 
  K(P1,P1) =        0
 
  K(P1,P2) should equal K(P2,P1).
 
  K(P1,P2) =        7
  K(P2,P1) =        7
 
  K(P1,P3) <= K(P1,P2) + K(P2,P3).
 
  K(P1,P3) =        6
  K(P1,P2) =        7
  K(P2,P3) =        6
  K(P1,P2) + K(P2,P3) =       13
 
TEST092
  PERM_FIXED_ENUM enumerates the permutations
  of N objects that leave M unchanged.
 
  For this test, N =       10
 
  M    F(N,M)
 
    0   1334961
    1   1334960
    2    667485
    3    222480
    4     55650
    5     11088
    6      1890
    7       240
    8        45
    9         0
   10         1
 
TEST094
  PERM_INVERSE inverts a permutation in place;
 
 
  The original permutation:
 
     1   2   3   4   5   6   7
     4   3   5   1   7   6   2
 
  The inverted permutation:
 
     1   2   3   4   5   6   7
     4   7   2   1   3   6   5
 
TEST095
  PERM_INVERSE2 inverts a permutation in place.
 
  The original permutation:
 
     1   2   3   4   5   6   7
     4   3   5   1   7   6   2
 
  The inverted permutation:
 
     1   2   3   4   5   6   7
     4   7   2   1   3   6   5
 
TEST0955
  PERM_INVERSE3 inverts a permutation.
 
  The original permutation:
 
     1   2   3   4   5   6   7
     4   3   5   1   7   6   2
 
  The inverted permutation:
 
     1   2   3   4   5   6   7
     4   7   2   1   3   6   5
 
TEST096
  PERM_LEX_NEXT generates permutations in order.
 
     1   2   3   4
     1   2   4   3
     1   3   2   4
     1   3   4   2
     1   4   2   3
     1   4   3   2
     2   1   3   4
     2   1   4   3
     2   3   1   4
     2   3   4   1
     2   4   1   3
     2   4   3   1
     3   1   2   4
     3   1   4   2
     3   2   1   4
     3   2   4   1
     3   4   1   2
     3   4   2   1
     4   1   2   3
     4   1   3   2
     4   2   1   3
     4   2   3   1
     4   3   1   2
     4   3   2   1
 
TEST097
  PERM_LEX_NEXT generates permutations in order.
  PERM_SIGN computes the sign of a permutation.
 
  RANK  SIGN  Permutation
 
     0     1     1   2   3   4
     1    -1     1   2   4   3
     2    -1     1   3   2   4
     3     1     1   3   4   2
     4     1     1   4   2   3
     5    -1     1   4   3   2
     6    -1     2   1   3   4
     7     1     2   1   4   3
     8     1     2   3   1   4
     9    -1     2   3   4   1
    10    -1     2   4   1   3
    11     1     2   4   3   1
    12     1     3   1   2   4
    13    -1     3   1   4   2
    14    -1     3   2   1   4
    15     1     3   2   4   1
    16     1     3   4   1   2
    17    -1     3   4   2   1
    18    -1     4   1   2   3
    19     1     4   1   3   2
    20     1     4   2   1   3
    21    -1     4   2   3   1
    22    -1     4   3   1   2
    23     1     4   3   2   1
 
TEST098
  PERM_MUL multiplies two permutations.
 
 
  Permutation P1:
 
     1   2   3   4   5
     2   5   1   3   4
 
  Permutation P2:
 
     1   2   3   4   5
     3   2   1   4   5
 
  Product permutation:
 
     1   2   3   4   5
     2   5   3   1   4
 
TEST099
  PERM_NEXT generates permutations.
 
     1   2   3   4
     2   1   3   4
     3   1   2   4
     1   3   2   4
     2   3   1   4
     3   2   1   4
     4   2   1   3
     2   4   1   3
     1   4   2   3
     4   1   2   3
     2   1   4   3
     1   2   4   3
     1   3   4   2
     3   1   4   2
     4   1   3   2
     1   4   3   2
     3   4   1   2
     4   3   1   2
     4   3   2   1
     3   4   2   1
     2   4   3   1
     4   2   3   1
     3   2   4   1
     2   3   4   1
 
TEST100
  PERM_NEXT2 generates permutations in order.
 
     1   2   3   4
     1   2   4   3
     1   4   2   3
     4   1   2   3
     4   1   3   2
     1   4   3   2
     1   3   4   2
     1   3   2   4
     3   1   2   4
     3   1   4   2
     3   4   1   2
     4   3   1   2
     4   3   2   1
     3   4   2   1
     3   2   4   1
     3   2   1   4
     2   3   1   4
     2   3   4   1
     2   4   3   1
     4   2   3   1
     4   2   1   3
     2   4   1   3
     2   1   4   3
     2   1   3   4
 
TEST101
  PERM_NEXT3 generates permutations in order.
 
     1   2   3   4
     1   2   4   3
     1   4   2   3
     4   1   2   3
     4   1   3   2
     1   4   3   2
     1   3   4   2
     1   3   2   4
     3   1   2   4
     3   1   4   2
     3   4   1   2
     4   3   1   2
     4   3   2   1
     3   4   2   1
     3   2   4   1
     3   2   1   4
     2   3   1   4
     2   3   4   1
     2   4   3   1
     4   2   3   1
     4   2   1   3
     2   4   1   3
     2   1   4   3
     2   1   3   4
 
TEST102
  PERM_RANDOM produces a random permutation;
  For this test, N =        4
 
     1   4   2   3
     3   1   2   4
     2   1   3   4
     3   2   1   4
     2   4   1   3
 
TEST103
  PERM_RANDOM2 produces a random permutation of labels;
  For this test, N =        4
 
   101 404 202 303
   303 101 202 404
   202 101 303 404
   303 202 101 404
   202 404 101 303
 
TEST104
  PERM_RANDOM3 produces a random permutation.
  For this test, N =        4
 
     2   1   4   3
     4   1   3   2
     1   3   4   2
     4   2   1   3
     3   4   2   1
 
TEST105
  PERM_RANK ranks a permutation.
 
  The permutation:
 
     1   2   3   4
     1   4   2   3
 
  The rank is:       3
 
TEST106
  PERM_TO_EQUIV returns the set partition
  or equivalence classes determined by a
  permutation.
 
  The input permutation:
 
     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1
 
  The partition:
 
   Set  Size
       1       4 ::    1   2   3   9
       2       3 ::    4   6   8
       3       2 ::    5   7
 
TEST107
  PERM_TO_YTB converts a permutation to a
  Young table.
 
  The permutation:
 
     1   2   3   4   5   6   7
     7   2   4   1   5   3   6
 
  The Young table:
 
   1   3   5   6
   2   4
   7
 
TEST108
  PERM_UNRANK, given a rank, computes the
  corresponding permutation.
 
  The requested rank is        6
 
  The permutation:
 
     1   2   3   4
     1   4   3   2
 
TEST1085
  PERRIN computes the Perrin numbers.
 
 
     N        P(N)
 
         0         3
         1         0
         2         2
         3         3
         4         2
         5         5
         6         5
         7         7
         8        10
         9        12
        10        17
        11        22
        12        29
        13        39
        14        51
 
TEST109
  POWER_MOD computes the remainder of a power
  of an integer modulo another integer.
 
  A =        7
  N =       50
  M =       11
  mod ( A**N, M ) =        1
 
  A =        3
  N =      118
  M =      119
  mod ( A**N, M ) =       32
 
TEST110
  POWER_SERIES1 composes a power series;
 
  Power series of G(x) = (1+F(x))**alpha
 
  N =       10
  ALPHA =    7.00000    
 
  Series for F(x):
 
     1.00000       0.00000       0.00000       0.00000       0.00000    
     0.00000       0.00000       0.00000       0.00000       0.00000    
  Series for G(x):
 
     7.00000       21.0000       35.0000       35.0000       21.0000    
     7.00000       1.00000       0.00000       0.00000       0.00000    
 
TEST111
  POWER_SERIES2 composes a power series;
  Here we compute the power series of G(x) = exp(F(x))-1
  The number of terms is N =        4
 
  Series for F(x):
 
    -4.00000       0.00000       0.00000       0.00000    
 
  Series for G(x):
 
    -4.00000       8.00000      -10.6667       10.6667    
 
TEST112
  POWER_SERIES3 composes a power series;
 
  Power series of H(x) = G(F(x))
 
  Number of terms, N =        4
 
  Series for F(x):
 
     1.00000       1.00000       0.00000       0.00000    
 
  Series for G(x):
 
     1.00000       1.00000       0.00000       0.00000    
 
  Series for H(x):
 
     1.00000       2.00000       2.00000       3.00000    
 
TEST113
  POWER_SERIES4 composes a power series;
 
  Power series of H(x) = G(1/F(x))
 
  N =       10
 
  Series for F(x):
 
     1.00000      0.500000      0.333333      0.250000      0.200000    
    0.166667      0.142857      0.125000      0.111111      0.100000    
 
  Series for G(x):
 
     1.00000       0.00000       0.00000       0.00000       0.00000    
     0.00000       0.00000       0.00000       0.00000       0.00000    
 
  Series for H(x):
 
     1.00000     -0.500000      0.166667     -0.416667E-01  0.833333E-02
   -0.138889E-02  0.198413E-03 -0.248016E-04  0.275573E-05 -0.275573E-06
 
TEST114
  PYTHAG_TRIPLE_NEXT computes the "next"
  Pythagorean triple.
 
   I   J   A   B   C  A^2+B^2   C^2
 
     2   1   3   4   5      25      25
     3   2   5  12  13     169     169
     4   1  15   8  17     289     289
     4   3   7  24  25     625     625
     5   2  21  20  29     841     841
     5   4   9  40  41    1681    1681
     6   1  35  12  37    1369    1369
     6   3  27  36  45    2025    2025
     6   5  11  60  61    3721    3721
     7   2  45  28  53    2809    2809
     7   4  33  56  65    4225    4225
     7   6  13  84  85    7225    7225
     8   1  63  16  65    4225    4225
     8   3  55  48  73    5329    5329
     8   5  39  80  89    7921    7921
     8   7  15 112 113   12769   12769
     9   2  77  36  85    7225    7225
     9   4  65  72  97    9409    9409
     9   6  45 108 117   13689   13689
     9   8  17 144 145   21025   21025
    10   1  99  20 101   10201   10201
 
TEST115
  R8_AGM computes the arithmetic-geometric mean (AGM)
  of two nonnegative real numbers.
 
    X        Y    R8_AGM(X,Y)
 
    3.0000   10.0000    5.9777
    9.0000    6.0000    7.4240
    5.0000    1.0000    2.6040
    3.0000    2.0000    2.4747
    1.0000    7.0000    3.2879
    1.0000    5.0000    2.6040
    5.0000    8.0000    6.4120
    8.0000    1.0000    3.6158
    9.0000    4.0000    6.2475
    1.0000    1.0000    1.0000
 
TEST030
  R8_FALL computes the falling factorial function.
  [X]_N = X * (X-1) * (X-2) * ... * ( X-N+1).
 
    X          N  R8_FALL(X,N)
 
    4.000000      -2 20.000000
    4.000000      -1  4.000000
    4.000000       0  1.000000
    4.000000       1  4.000000
    4.000000       2 12.000000
    4.000000       3 24.000000
    4.000000       4 24.000000
    4.000000       5  0.000000
 
TEST1245
  R8_RISE computes the rising factorial function.
  [X]_N = X * (X+1) * (X+2) * ... * ( X+N-1).
 
    X          N  R8_RISE(X,N)
 
    4.000000      -2   12.000000
    4.000000      -1    4.000000
    4.000000       0    1.000000
    4.000000       1    4.000000
    4.000000       2   20.000000
    4.000000       3  120.000000
    4.000000       4  840.000000
    4.000000       5 6720.000000
 
TEST116
  R8_TO_CFRAC converts a real number to a sequence
  of continued fraction convergents.
 
  Use the real number R =    6.28319    
 
         6       6       1   6.00000      0.283185    
         3      19       3   6.33333     -0.501480E-01
         1      25       4   6.25000      0.331853E-01
         1      44       7   6.28571     -0.252898E-02
         7     333      53   6.28302      0.166439E-03
         2     710     113   6.28319     -0.533528E-06
       146  103993   16551   6.28319      0.115578E-08
         3  312689   49766   6.28319     -0.582867E-10
 
TEST1163
  R8_TO_DEC converts a real number to a decimal;
  DEC_TO_R8 converts a decimal to a real number.
 
  The number of decimal digits is   5
 
     R   =>  A * 10^B  =>  R2
 
   -0.315817    -31582        -5   -0.315820
    7.063176     70632        -4    7.063200
    5.795092     57951        -4    5.795100
    3.116954      3117        -3    3.117000
    1.653071     16531        -4    1.653100
   -1.838813    -18388        -4   -1.838800
    0.075778     75778        -6    0.075778
   -1.400432    -14004        -4   -1.400400
   -2.061710    -20617        -4   -2.061700
    3.839657     38397        -4    3.839700
 
TEST1165
  R8_TO_RAT converts a real number to a rational;
  RAT_TO_R8 converts a rational to a real number.
 
  The maximum number of digits allowed is   4
 
     R   =>  A / B  =>  R2
 
   -0.315817   -1579      5000 -0.315800
    7.063176    8829      1250  7.063200
    5.795092   57951     10000  5.795100
    3.116954    3117      1000  3.117000
    1.653071   16531     10000  1.653100
   -1.838813   -4597      2500 -1.838800
    0.075778     379      5000  0.075800
   -1.400432   -3501      2500 -1.400400
   -2.061710  -20617     10000 -2.061700
    3.839657   38397     10000  3.839700
 
TEST117
  RAT_ADD adds two rationals.
 
  A = 3/4
  B = 10/7
  C = A + B = 61/28
 
TEST118
  RAT_DIV divides two rationals.
 
  A = 3/4
  B = 10/7
  C = A / B = 21/40
 
TEST119
  RAT_FAREY computes a row of the Farey fraction table.
 
  Row        1
  Number of fractions:        2
 
    0  1
    1  1
 
  Row        2
  Number of fractions:        3
 
    0  1  1
    1  2  1
 
  Row        3
  Number of fractions:        5
 
    0  1  1  2  1
    1  3  2  3  1
 
  Row        4
  Number of fractions:        7
 
    0  1  1  1  2  3  1
    1  4  3  2  3  4  1
 
  Row        5
  Number of fractions:       11
 
    0  1  1  1  2  1  3  2  3  4  1
    1  5  4  3  5  2  5  3  4  5  1
 
  Row        6
  Number of fractions:       13
 
    0  1  1  1  1  2  1  3  2  3  4  5  1
    1  6  5  4  3  5  2  5  3  4  5  6  1
 
  Row        7
  Number of fractions:       19
 
    0  1  1  1  1  2  1  2  3  1  4  3  2  5  3  4  5  6  1
    1  7  6  5  4  7  3  5  7  2  7  5  3  7  4  5  6  7  1
 
TEST120
  RAT_FAREY2 computes a row of the Farey fraction table.
 
  Row        1
 
    0  1
    1  1
 
  Row        2
 
    0  1  1
    1  2  1
 
  Row        3
 
    0  1  1  2  1
    1  3  2  3  1
 
  Row        4
 
    0  1  1  2  1  3  2  3  1
    1  4  3  5  2  5  3  4  1
 
  Row        5
 
    0  1  1  2  1  3  2  3  1  4  3  5  2  5  3  4  1
    1  5  4  7  3  8  5  7  2  7  5  8  3  7  4  5  1
 
TEST121
  RAT_MUL multiplies two rationals.
 
  A = 3/4
  B = 10/7
  C = A * B = 15/14
 
TEST1215
  RAT_WIDTH determines the "width" of a rational.
 
     Top    Bottom  Width
 
      1000       3       4
      1000      40       4
      1000     500       4
      1000    6000       4
      1000   70000       5
         1       1       1
        -1     200       3
       -10     200       3
      -100     200       4
     -1000     200       5
         1    -200       3
        10    -200       3
       100    -200       4
      1000    -200       5
     10000    -200       6
        17    3000       4
   4000000 4000000       7
 
TEST122
  RAT_SUM_FORMULA computes the coefficients for the
  formulas for the sums of powers of integers.
 
  Power Sum Coefficients:
 
    1    0    0    0    0    0    0

 
    1    1    0    0    0    0    0
    2    2
 
    1    1    1    0    0    0    0
    3    2    6
 
    1    1    1    0    0    0    0
    4    2    4
 
    1    1    1    0   -1    0    0
    5    2    3        30
 
    1    1    5    0   -1    0    0
    6    2   12        12
 
    1    1    1    0   -1    0    1
    7    2    2         6        42
 
TEST123
  RATMAT_DET: determinant of a rational matrix.
 
 
  The 123/456/789 matrix:
 
   1   2   3

 
   4   5   6

 
   7   8   9

 
  Determinant of the 123/456/789 matrix:
         0 /        1
 
  The Hilbert matrix:
 
   1   1   1
   2   3   4
 
   1   1   1
   3   4   5
 
   1   1   1
   4   5   6
 
  Determinant of the Hilbert matrix:
         1 /    43200
 
  The -1 2 -1 matrix:
 
   2  -1   0

 
  -1   2  -1

 
   0  -1   2

 
  Determinant of the -1,2,-1 matrix:
         4 /        1
 
TEST124
  REGRO_NEXT generates all restricted growth 
  functions.
 
    1  1  1  1  1
    2  1  1  1  2
    3  1  1  2  1
    4  1  1  2  2
    5  1  1  2  3
    6  1  2  1  1
    7  1  2  1  2
    8  1  2  1  3
    9  1  2  2  1
   10  1  2  2  2
   11  1  2  2  3
   12  1  2  3  1
   13  1  2  3  2
   14  1  2  3  3
   15  1  2  3  4
 
TEST125
  R8MAT_DET: determinant of a real matrix.
 
 
  The 123/456/789 matrix:
 
  Col         1             2             3       
  Row
 
    1       1.            2.            3.      
    2       4.            5.            6.      
    3       7.            8.            9.      
 
  Determinant of the 123/456/789 matrix is    0.00000    
 
  The Hilbert matrix:
 
  Col         1             2             3             4       
  Row
 
    1   0.500000      0.333333      0.250000      0.200000    
    2   0.333333      0.250000      0.200000      0.166667    
    3   0.250000      0.200000      0.166667      0.142857    
    4   0.200000      0.166667      0.142857      0.125000    
 
  Determinant of the Hilbert matrix is   0.236206E-08
 
  The -1,2,-1 matrix:
 
  Col         1             2             3       
  Row
 
    1       2.           -1.            0.      
    2      -1.            2.           -1.      
    3       0.           -1.            2.      
 
  Determinant of the -1,2,-1 matrix is    4.00000    
 
TEST126
  R8MAT_PERM reorders a real matrix in place.
  The rows and columns use the same permutation.
 
  The original matrix
 
  Col         1             2             3             4             5       
  Row
 
    1      11.           12.           13.           14.           15.      
    2      21.           22.           23.           24.           25.      
    3      31.           32.           33.           34.           35.      
    4      41.           42.           43.           44.           45.      
    5      51.           52.           53.           54.           55.      
    6      61.           62.           63.           64.           65.      
    7      71.           72.           73.           74.           75.      
    8      81.           82.           83.           84.           85.      
    9      91.           92.           93.           94.           95.      
 
  Col         6             7             8             9       
  Row
 
    1      16.           17.           18.           19.      
    2      26.           27.           28.           29.      
    3      36.           37.           38.           39.      
    4      46.           47.           48.           49.      
    5      56.           57.           58.           59.      
    6      66.           67.           68.           69.      
    7      76.           77.           78.           79.      
    8      86.           87.           88.           89.      
    9      96.           97.           98.           99.      
 
  The row and column permutation:
 
     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1
 
  The permuted matrix
 
  Col         1             2             3             4             5       
  Row
 
    1      99.           91.           92.           98.           97.      
    2      19.           11.           12.           18.           17.      
    3      29.           21.           22.           28.           27.      
    4      89.           81.           82.           88.           87.      
    5      79.           71.           72.           78.           77.      
    6      49.           41.           42.           48.           47.      
    7      59.           51.           52.           58.           57.      
    8      69.           61.           62.           68.           67.      
    9      39.           31.           32.           38.           37.      
 
  Col         6             7             8             9       
  Row
 
    1      94.           95.           96.           93.      
    2      14.           15.           16.           13.      
    3      24.           25.           26.           23.      
    4      84.           85.           86.           83.      
    5      74.           75.           76.           73.      
    6      44.           45.           46.           43.      
    7      54.           55.           56.           53.      
    8      64.           65.           66.           63.      
    9      34.           35.           36.           33.      
 
TEST127
  R8MAT_PERM2 reorders a real matrix in place.
  Rows and columns use different permutations.
 
  The original matrix
 
  Col         1             2             3             4             5       
  Row
 
    1      11.           12.           13.           14.           15.      
    2      21.           22.           23.           24.           25.      
    3      31.           32.           33.           34.           35.      
    4      41.           42.           43.           44.           45.      
    5      51.           52.           53.           54.           55.      
    6      61.           62.           63.           64.           65.      
    7      71.           72.           73.           74.           75.      
    8      81.           82.           83.           84.           85.      
    9      91.           92.           93.           94.           95.      
 
  Col         6             7       
  Row
 
    1      16.           17.      
    2      26.           27.      
    3      36.           37.      
    4      46.           47.      
    5      56.           57.      
    6      66.           67.      
    7      76.           77.      
    8      86.           87.      
    9      96.           97.      
 
  The row permutation:
 
     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1
 
  The column permutation:
 
     1   2   3   4   5   6   7
     3   4   5   6   7   1   2
 
  The permuted matrix
 
  Col         1             2             3             4             5       
  Row
 
    1      96.           97.           91.           92.           93.      
    2      16.           17.           11.           12.           13.      
    3      26.           27.           21.           22.           23.      
    4      86.           87.           81.           82.           83.      
    5      76.           77.           71.           72.           73.      
    6      46.           47.           41.           42.           43.      
    7      56.           57.           51.           52.           53.      
    8      66.           67.           61.           62.           63.      
    9      36.           37.           31.           32.           33.      
 
  Col         6             7       
  Row
 
    1      94.           95.      
    2      14.           15.      
    3      24.           25.      
    4      84.           85.      
    5      74.           75.      
    6      44.           45.      
    7      54.           55.      
    8      64.           65.      
    9      34.           35.      
 
TEST128
  R8MAT_PERMANENT: the matrix permanent function.
  We will analyze matrices with 0 diagonal and
  1 on all offdiagonals.
 
  Order	    Permanent.
 
        2           1.000000000    
        3           2.000000000    
        4           9.000000000    
        5           44.00000000    
        6           265.0000000    
        7           1854.000000    
        8           14833.00000    
        9           133496.0000    
       10           1334961.000    
       11           14684570.00    
       12           176214841.0    
 
TEST129
  R8POLY converts between power sum, factorial
  and Taylor forms, and can evaluate a polynomial
 
  All calls have input A as follows
     0.00   0.00   0.00   0.00   0.00   1.00
 
  Option IOPT =       -3
  Output array = 
     0.00  24.00 -50.00  35.00 -10.00   1.00
 
  Option IOPT =       -2
  Output array = 
     0.00   1.00  15.00  25.00  10.00   1.00
 
  Option IOPT =       -1
  X0 =    2.00000    
  Value =    0.00000    
 
  Option IOPT =        0
  X0 =    2.00000    
  Value =    32.0000    
 
  Option IOPT =        6
  X0 =    2.00000    
  Output array = 
    32.00  80.00  80.00  40.00  10.00   1.00
 
  Option IOPT =        6
  X0 =   -2.00000    
  Output array = 
   -32.00  80.00 -80.00  40.00 -10.00   1.00
 
TEST130
  R8POLY_DIV computes the quotient and
  remainder for polynomial division.
 
 
  The polynomial to be divided, A:
 
  p(x) =     1.00000     * x ^   3
         +   2.00000     * x ^   2
         -   5.00000     * x
         -   6.00000    
 
  The divisor polynomial, B:
 
  p(x) =     1.00000     * x
         -   2.00000    
 
  The quotient polynomial, Q:
 
  p(x) =     1.00000     * x ^   2
         +   4.00000     * x
         +   3.00000    
 
  The remainder polynomial, R:
 
  p(x) =     0.00000    
 
  The polynomial to be divided, A:
 
  p(x) =     1.00000     * x ^   4
         +   3.00000     * x ^   3
         +   2.00000     * x ^   2
         +   5.00000     * x
         -   2.00000    
 
  The divisor polynomial, B:
 
  p(x) =     1.00000     * x ^   2
         +   1.00000     * x
         -   3.00000    
 
  The quotient polynomial, Q:
 
  p(x) =     1.00000     * x ^   2
         +   2.00000     * x
         +   3.00000    
 
  The remainder polynomial, R:
 
  p(x) =     8.00000     * x
         +   7.00000    
 
TEST131
  R8POLY_P2F: power sum => factorial;
  R8POLY_F2P: factorial => power sum.
 
  The power sum polynomial:
 
  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    
 
  The factorial polynomial coefficients:
 
       1   1.00000    
       2   9.00000    
       3   15.0000    
       4   4.00000    
 
  The recovered power sum polynomial:
 
  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    
 
TEST132
  R8POLY_FVAL evaluates a polynomial in factorial form.
 
  The factorial polynomial coefficients:
 
       1   1.00000    
       2   2.00000    
       3   3.00000    
       4   4.00000    
       5   5.00000    
 
  R8POLY (   2.00000     ) =    11.0000    
  The correct value is 11.
 
TEST133
  R8POLY_MUL multiplies two polynomials.
 
 
  The factor A:
 
  p(x) =     1.00000     * x
         +   1.00000    
 
  The factor B:
 
  p(x) = -   1.00000     * x
         +   1.00000    
 
  The product C = A*B:
 
  p(x) = -   1.00000     * x ^   2
         +   1.00000    
 
  The factor A:
 
  p(x) =     3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    
 
  The factor B:
 
  p(x) = -   2.00000     * x
         +   1.00000    
 
  The product C = A*B:
 
  p(x) = -   6.00000     * x ^   3
         -   1.00000     * x ^   2
         +   1.00000    
 
TEST134
  R8POLY_N2P: Newton => power sum;
  R8POLY_P2N: Power sum => Newton.
 
  The power sum polynomial:
 
  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    
 
  Newton polynomial coefficients:
 
     49.0000    132.0000     51.0000      4.0000
 
  Newton polynomial abscissas:
 
      2.0000      4.0000      6.0000      8.0000
 
  The recovered power sum polynomial:
 
  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    
 
TEST135
  R8POLY_NVAL evaluates a Newton polynomial.
 
  Newton polynomial coefficients:
 
        1.0000      2.0000      3.0000      4.0000      5.0000
 
  Newton polynomial abscissas:
 
        0.0000      1.0000      2.0000      3.0000
 
  R8POLY (    2.00000     ) =    11.0000    
  The correct value is 11.
 
TEST136
  R8POLY_T2P: Taylor => Power sum;
  R8POLY_P2T: Power sum => Taylor.
 
  Taylor expansion point is X =    2.00000    
 
  The Taylor coefficients:
 
        1.0000      2.0000      3.0000      4.0000
 
  The power sum polynomial:
 
  p(x) =     4.00000     * x ^   3
         -   21.0000     * x ^   2
         +   38.0000     * x
         -   23.0000    
 
  The recovered Taylor coefficients:
 
        1.0000      2.0000      3.0000      4.0000
 
TEST137
  R8POLY_POWER takes a polynomial to a power.
 
  The polynomial A:
 
  p(x) = -   1.00000     * x
         +   2.00000    
 
  Raised to the power 3:
 
  p(x) =     0.00000    
 
  The polynomial A:
 
  p(x) =     1.00000     * x ^   2
         +   1.00000     * x
 
  Raised to the power 2:
 
  p(x) =     1.00000     * x ^   4
         +   2.00000     * x ^   3
         +   1.00000     * x ^   2
 
TEST138
  R8POLY_PVAL evaluates a polynomial
  in power sum form.
 
  The polynomial to be evaluated:
 
  p(x) =     5.00000     * x ^   4
         +   4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    
 
  At X =    2.00000    
  Computed polynomial value is    129.000    
  Correct value is 129.
 
TEST139
  R8VEC_FRAC: K-th smallest real vector entry;
 
  The real array to search:
 
       1   2.18418    
       2   9.56318    
       3   8.29509    
       4   5.61695    
       5   4.15307    
       6  0.661187    
       7   2.57578    
       8   1.09957    
       9  0.438290    
      10   6.33966    
 
  Frac   R8VEC_FRAC
 
     1    0.438290    
     2    0.661187    
     3     1.09957    
     4     2.18418    
     5     2.57578    
     6     4.15307    
     7     5.61695    
     8     6.33966    
     9     8.29509    
    10     9.56318    
 
TEST1395
  R8VEC_MIRROR_NEXT generates all sign variations
  of a real vector.
 
  Next vector:
 
       1   1.00000    
       2   2.00000    
       3   3.00000    
 
  Next vector:
 
       1  -1.00000    
       2   2.00000    
       3   3.00000    
 
  Next vector:
 
       1   1.00000    
       2  -2.00000    
       3   3.00000    
 
  Next vector:
 
       1  -1.00000    
       2  -2.00000    
       3   3.00000    
 
  Next vector:
 
       1   1.00000    
       2   2.00000    
       3  -3.00000    
 
  Next vector:
 
       1  -1.00000    
       2   2.00000    
       3  -3.00000    
 
  Next vector:
 
       1   1.00000    
       2  -2.00000    
       3  -3.00000    
 
  Next vector:
 
       1  -1.00000    
       2  -2.00000    
       3  -3.00000    
 
  Done.
 
  Next vector:
 
       1   1.00000    
       2   0.00000    
       3   3.00000    
 
  Next vector:
 
       1  -1.00000    
       2   0.00000    
       3   3.00000    
 
  Next vector:
 
       1   1.00000    
       2  -0.00000    
       3  -3.00000    
 
  Next vector:
 
       1  -1.00000    
       2  -0.00000    
       3  -3.00000    
 
  Done.
 
TEST140
  SCHROEDER computes the Schroeder numbers.
 
 
       N        S(N)
 
         1         1
         2         1
         3         3
         4        11
         5        45
         6       197
         7       903
         8      4279
         9     20793
        10    103049
 
TEST141
  SORT_HEAP_EXTERNAL sorts objects externally.
 
 
  Unsorted array:
 
       1         5
       2        20
       3        17
       4        12
       5         9
       6         2
       7         6
       8         3
       9         1
      10        13
      11         2
      12         9
      13         9
      14        16
      15        16
      16         1
      17        18
      18         8
      19         2
      20         1
 
  Sorted array:
 
       1         1
       2         1
       3         1
       4         2
       5         2
       6         2
       7         3
       8         5
       9         6
      10         8
      11         9
      12         9
      13         9
      14        12
      15        13
      16        16
      17        16
      18        17
      19        18
      20        20
 
TEST142
  SUBSET_BY_SIZE_NEXT generates all subsets of an N set.
 
     1     1 2 3 4 5
     2     1 2 3 4
     3     1 2 3 5
     4     1 2 4 5
     5     1 3 4 5
     6     2 3 4 5
     7     1 2 3
     8     1 2 4
     9     1 2 5
    10     1 3 4
    11     1 3 5
    12     1 4 5
    13     2 3 4
    14     2 3 5
    15     2 4 5
    16     3 4 5
    17     1 2
    18     1 3
    19     1 4
    20     1 5
    21     2 3
    22     2 4
    23     2 5
    24     3 4
    25     3 5
    26     4 5
    27     1
    28     2
    29     3
    30     4
    31     5
    32    The empty set
 
TEST143
  SUBSET_LEX_NEXT generates all subsets of an N set.
 
     1     1
     2     1 2
     3     1 2 3
     4     1 2 3 4
     5     1 2 3 4 5
     6     1 2 3 5
     7     1 2 4
     8     1 2 4 5
     9     1 2 5
    10     1 3
    11     1 3 4
    12     1 3 4 5
    13     1 3 5
    14     1 4
    15     1 4 5
    16     1 5
    17     2
    18     2 3
    19     2 3 4
    20     2 3 4 5
    21     2 3 5
    22     2 4
    23     2 4 5
    24     2 5
    25     3
    26     3 4
    27     3 4 5
    28     3 5
    29     4
    30     4 5
    31     5
    32    The empty set.
 
TEST1435
  SUBSET_LEX_NEXT generates all subsets of an N set.
  The user can impose a restriction on the
  maximum size of the subsets.
 
  Here, we require the subsets to be no larger
  than        3
   1
   1 2
   1 2 3
   1 2 4
   1 2 5
   1 3
   1 3 4
   1 3 5
   1 4
   1 4 5
   1 5
   2
   2 3
   2 3 4
   2 3 5
   2 4
   2 4 5
   2 5
   3
   3 4
   3 4 5
   3 5
   4
   4 5
   5
  The empty set.
 
TEST144
  SUBSET_GRAY_NEXT generates all subsets of an N set.
  using the Gray code ordering:
  0 0 1 0 1 means the subset contains 3 and 5.
 
  Gray code
 
     1     0 0 0 0 0
     2     1 0 0 0 0
     3     1 1 0 0 0
     4     0 1 0 0 0
     5     0 1 1 0 0
     6     1 1 1 0 0
     7     1 0 1 0 0
     8     0 0 1 0 0
     9     0 0 1 1 0
    10     1 0 1 1 0
    11     1 1 1 1 0
    12     0 1 1 1 0
    13     0 1 0 1 0
    14     1 1 0 1 0
    15     1 0 0 1 0
    16     0 0 0 1 0
    17     0 0 0 1 1
    18     1 0 0 1 1
    19     1 1 0 1 1
    20     0 1 0 1 1
    21     0 1 1 1 1
    22     1 1 1 1 1
    23     1 0 1 1 1
    24     0 0 1 1 1
    25     0 0 1 0 1
    26     1 0 1 0 1
    27     1 1 1 0 1
    28     0 1 1 0 1
    29     0 1 0 0 1
    30     1 1 0 0 1
    31     1 0 0 0 1
    32     0 0 0 0 1
 
TEST145
  SUBSET_RANDOM picks a subset at random.
  The number of elements in the main set is        5
 
   0 1 1 1 0
   0 0 0 0 1
   0 0 0 1 1
   0 1 0 0 0
   1 1 0 0 0
 
TEST146
  SUBSET_GRAY_RANK returns rank of a subset of an N set
  using the Gray code ordering.
 
  For N =        5
  the subset is:
   1 0 1 1 0
 
  The rank is       28
 
TEST147
  SUBSET_GRAY_UNRANK finds the subset of an N set
  of a given rank under the Gray code ordering.
 
  N is        5
 
  Rank   Subset
 
     1     0 0 0 0 0
     2     0 0 0 0 1
     3     0 0 0 1 1
     4     0 0 0 1 0
     5     0 0 1 1 0
     6     0 0 1 1 1
     7     0 0 1 0 1
     8     0 0 1 0 0
     9     0 1 1 0 0
    10     0 1 1 0 1
 
TEST1475
  SUBCOMP_NEXT generates subcompositions.
 
  Seek all subcompositions of N =        6
  using K =        3 parts.
 
     #   Sum
 
     1     0     0   0   0
     2     1     1   0   0
     3     1     0   1   0
     4     1     0   0   1
     5     2     2   0   0
     6     2     1   1   0
     7     2     0   2   0
     8     2     1   0   1
     9     2     0   1   1
    10     2     0   0   2
    11     3     3   0   0
    12     3     2   1   0
    13     3     1   2   0
    14     3     0   3   0
    15     3     2   0   1
    16     3     1   1   1
    17     3     0   2   1
    18     3     1   0   2
    19     3     0   1   2
    20     3     0   0   3
    21     4     4   0   0
    22     4     3   1   0
    23     4     2   2   0
    24     4     1   3   0
    25     4     0   4   0
    26     4     3   0   1
    27     4     2   1   1
    28     4     1   2   1
    29     4     0   3   1
    30     4     2   0   2
    31     4     1   1   2
    32     4     0   2   2
    33     4     1   0   3
    34     4     0   1   3
    35     4     0   0   4
    36     5     5   0   0
    37     5     4   1   0
    38     5     3   2   0
    39     5     2   3   0
    40     5     1   4   0
    41     5     0   5   0
    42     5     4   0   1
    43     5     3   1   1
    44     5     2   2   1
    45     5     1   3   1
    46     5     0   4   1
    47     5     3   0   2
    48     5     2   1   2
    49     5     1   2   2
    50     5     0   3   2
    51     5     2   0   3
    52     5     1   1   3
    53     5     0   2   3
    54     5     1   0   4
    55     5     0   1   4
    56     5     0   0   5
    57     6     6   0   0
    58     6     5   1   0
    59     6     4   2   0
    60     6     3   3   0
    61     6     2   4   0
    62     6     1   5   0
    63     6     0   6   0
    64     6     5   0   1
    65     6     4   1   1
    66     6     3   2   1
    67     6     2   3   1
    68     6     1   4   1
    69     6     0   5   1
    70     6     4   0   2
    71     6     3   1   2
    72     6     2   2   2
    73     6     1   3   2
    74     6     0   4   2
    75     6     3   0   3
    76     6     2   1   3
    77     6     1   2   3
    78     6     0   3   3
    79     6     2   0   4
    80     6     1   1   4
    81     6     0   2   4
    82     6     1   0   5
    83     6     0   1   5
    84     6     0   0   6
 
TEST1476
  SUBCOMPNZ_NEXT generates subcompositions
  using nonzero parts.
 
  Seek all subcompositions of N =        6
  using K =        3 nonzero parts.
 
     #   Sum
 
     1     3     1   1   1
     2     4     2   1   1
     3     4     1   2   1
     4     4     1   1   2
     5     5     3   1   1
     6     5     2   2   1
     7     5     1   3   1
     8     5     2   1   2
     9     5     1   2   2
    10     5     1   1   3
    11     6     4   1   1
    12     6     3   2   1
    13     6     2   3   1
    14     6     1   4   1
    15     6     3   1   2
    16     6     2   2   2
    17     6     1   3   2
    18     6     2   1   3
    19     6     1   2   3
    20     6     1   1   4
 
TEST1477
  SUBCOMPNZ2_NEXT generates subcompositions
  using nonzero parts.
 
  Seek all subcompositions of N
  using K =        3 nonzero parts.
 
  N ranges from        5 to        7
 
     #     N
 
     1     5     3   1   1
     2     5     2   2   1
     3     5     1   3   1
     4     5     2   1   2
     5     5     1   2   2
     6     5     1   1   3
     7     6     4   1   1
     8     6     3   2   1
     9     6     2   3   1
    10     6     1   4   1
    11     6     3   1   2
    12     6     2   2   2
    13     6     1   3   2
    14     6     2   1   3
    15     6     1   2   3
    16     6     1   1   4
    17     7     5   1   1
    18     7     4   2   1
    19     7     3   3   1
    20     7     2   4   1
    21     7     1   5   1
    22     7     4   1   2
    23     7     3   2   2
    24     7     2   3   2
    25     7     1   4   2
    26     7     3   1   3
    27     7     2   2   3
    28     7     1   3   3
    29     7     2   1   4
    30     7     1   2   4
    31     7     1   1   5
 
TEST1478
  SUBTRIANGLE_NEXT generates the indices of subtriangles
  in a triangle whose edges were divided into N subedges.
 
  For this test, N =        4
 
  Rank    I1  J1    I2  J2    I3  J3
 
     1     0   0     1   0     0   1
     2     1   1     0   1     1   0
     3     1   0     2   0     1   1
     4     2   1     1   1     2   0
     5     2   0     3   0     2   1
     6     3   1     2   1     3   0
     7     3   0     4   0     3   1
     8     0   1     1   1     0   2
     9     1   2     0   2     1   1
    10     1   1     2   1     1   2
    11     2   2     1   2     2   1
    12     2   1     3   1     2   2
    13     0   2     1   2     0   3
    14     1   3     0   3     1   2
    15     1   2     2   2     1   3
    16     0   3     1   3     0   4
 
TEST148
  THUE_BINARY_NEXT returns the next Thue binary sequence.
 
     1    0
     2    01
     4    0110
     8    01101001
    16    0110100110010110
    32    01101001100101101001011001101001
    64    0110100110010110100101100110100110010110011010010110100110010110
 
TEST149
  THUE_TERNARY_NEXT returns the next 
  Thue ternary sequence.
 
     1    1
     3    102
     6    102120
    12    102120102012
    24    102120102012102120121020
    48    102120102012102120121020102120102012102010212012
 
TEST150
  TUPLE_NEXT returns the next "tuple", that is,
  a vector of N integers, each between M1 and M2.
 
  M1 =        2
  M2 =        4
  N =         2
 
     1    2  2
     2    2  3
     3    2  4
     4    3  2
     5    3  3
     6    3  4
     7    4  2
     8    4  3
     9    4  4
 
TEST151
  TUPLE_NEXT_FAST returns the next "tuple", that is,
  a vector of N integers, each between 1 and M.
 
  M =        3
  N =        2
 
     0    1  1
     1    1  2
     2    1  3
     3    2  1
     4    2  2
     5    2  3
     6    3  1
     7    3  2
     8    3  3
 
TEST152
  TUPLE_NEXT_GE returns the next "tuple", that is,
  a vector of N integers, each between 1 and M,
  with the constraint that the entries be
  nondecreasing.
 
  M =        3
  N =        3
 
     1    1  1  1
     2    1  1  2
     3    1  1  3
     4    1  2  2
     5    1  2  3
     6    1  3  3
     7    2  2  2
     8    2  2  3
     9    2  3  3
    10    3  3  3
 
TEST153
  TUPLE_NEXT2 returns the next "tuple", that is,
  a vector of N integers.
 
  N =        3
 
  The minimum tuple is 
         2       3       8
  The maximum tuple is 
         4       3       5
 
     1    2  3  8
     2    2  3  7
     3    2  3  6
     4    2  3  5
     5    3  3  8
     6    3  3  7
     7    3  3  6
     8    3  3  5
     9    4  3  8
    10    4  3  7
    11    4  3  6
    12    4  3  5
 
TEST1531
  UBVEC_ADD adds unsigned binary vectors
  representing unsigned integers;
 
        I        J        K = I + J
 
 
        22        96
  Directly:                118
  UBVEC_ADD                118
 
        83        56
  Directly:                139
  UBVEC_ADD                139
 
        41         6
  Directly:                 47
  UBVEC_ADD                 47
 
        26        11
  Directly:                 37
  UBVEC_ADD                 37
 
         4        64
  Directly:                 68
  UBVEC_ADD                 68
 
         6        45
  Directly:                 51
  UBVEC_ADD                 51
 
        40        76
  Directly:                116
  UBVEC_ADD                116
 
        80         0
  Directly:                 80
  UBVEC_ADD                 80
 
        90        35
  Directly:                125
  UBVEC_ADD                125
 
         9         1
  Directly:                 10
  UBVEC_ADD                 10
 
TEST0626
  UI4_TO_UBVEC converts an unsigned integer to an 
  unsigned binary vector;
  UBVEC_TO_UI4 converts an unsigned binary vector
  to an unsigned integer;
 
  I --> BVEC  -->  I
 
    0  0000000000    0
    1  0000000001    1
    2  0000000010    2
    3  0000000011    3
    4  0000000100    4
    5  0000000101    5
    6  0000000110    6
    7  0000000111    7
    8  0000001000    8
    9  0000001001    9
   10  0000001010   10
 
TEST1535
  VEC_COLEX_NEXT generates all DIM_NUM-vectors
  in colex order in a given base BASE.
 
  The dimension DIM_NUM =        3
  The base BASE =                3
 
     0   0   0
     1   0   0
     2   0   0
     0   1   0
     1   1   0
     2   1   0
     0   2   0
     1   2   0
     2   2   0
     0   0   1
     1   0   1
     2   0   1
     0   1   1
     1   1   1
     2   1   1
     0   2   1
     1   2   1
     2   2   1
     0   0   2
     1   0   2
     2   0   2
     0   1   2
     1   1   2
     2   1   2
     0   2   2
     1   2   2
     2   2   2
 
TEST1536
  VEC_COLEX_NEXT2 generates all DIM_NUM-vectors
  in colex order in given bases BASE(1:DIM_NUM).
 
  The dimension DIM_NUM =        3
 
  The base vector:
 
     2   1   3
 
     0   0   0
     1   0   0
     0   0   1
     1   0   1
     0   0   2
     1   0   2
 
TEST1537
  VEC_COLEX_NEXT3 generates all DIM_NUM-vectors
  in colex order in given bases BASE(1:DIM_NUM).
 
  The dimension DIM_NUM =        3
 
  The base vector:
 
     2   1   3
 
     1   1   1
     2   1   1
     1   1   2
     2   1   2
     1   1   3
     2   1   3
 
TEST154
  VEC_LEX_NEXT generates all N-vectors
  in a given base.  Here we use base        3
 
     0   0   0
     0   0   1
     0   0   2
     0   1   0
     0   1   1
     0   1   2
     0   2   0
     0   2   1
     0   2   2
     1   0   0
     1   0   1
     1   0   2
     1   1   0
     1   1   1
     1   1   2
     1   2   0
     1   2   1
     1   2   2
     2   0   0
     2   0   1
     2   0   2
     2   1   0
     2   1   1
     2   1   2
     2   2   0
     2   2   1
     2   2   2
 
TEST155
  VEC_GRAY_NEXT generates product space elements.
  VEC_GRAY_RANK ranks them.
  VEC_GRAY_UNRANK unranks them.
 
  The number of components is        4
  The number of elements is       16
  Each component has its own number of degrees of
  freedom, which, for this example, are:
 
  Rank Change        2   2   1   4
 
     1     1         0   0   0   0
     2     4         0   0   0   1
     3     4         0   0   0   2
     4     4         0   0   0   3
     5     2         0   1   0   3
     6     4         0   1   0   2
     7     4         0   1   0   1
     8     4         0   1   0   0
     9     1         1   1   0   0
    10     4         1   1   0   1
    11     4         1   1   0   2
    12     4         1   1   0   3
    13     2         1   0   0   3
    14     4         1   0   0   2
    15     4         1   0   0   1
    16     4         1   0   0   0
 
  VEC_GRAY_RANK reports the element 
 
          1   1   0   2
 
  has rank       11
 
  VEC_GRAY_UNRANK reports the element of rank        7
  is:
 
          0   1   0   1
 
 
TEST156
  VEC_RANDOM generates a random N-vector
  in a given base.
  Here, we use base        3
 
     0   2   2
     1   1   0
     0   0   0
     1   0   1
     1   2   2
 
TEST1565
  VECTOR_CONSTRAINED_NEXT:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    P = Product X_MAX(1:N)
  Accept only vectors for which:
    sum ( (X(1:N)-1) * P / X_MAX(1:N) ) <= P
 
  X_MIN:   2   2   1
  X_MAX:   4   5   3
 
  Maximum allowed CONSTRAINT = P =           60
 
         1            27         2         2         1
         2            42         3         2         1
         3            57         4         2         1
         4            39         2         3         1
         5            54         3         3         1
         6            51         2         4         1
         7            47         2         2         2
         8            59         2         3         2
 
TEST1566
  VECTOR_CONSTRAINED_NEXT2:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    P = Product X_MAX(1:N)
  Accept only vectors for which:
    sum ( X(1:N) * P / X_MAX(1:N) ) <= P
 
  X_MIN:   1   1
  X_MAX:   5   6
 
  Maximum allowed CONSTRAINT = P =           30
 
         1            11         1         1
         2            17         2         1
         3            23         3         1
         4            29         4         1
         5            16         1         2
         6            22         2         2
         7            28         3         2
         8            21         1         3
         9            27         2         3
        10            26         1         4
 
  X_MIN:   1   1   1
  X_MAX:   5   6   4
 
  Maximum allowed CONSTRAINT = P =          120
 
         1            74         1         1         1
         2            98         2         1         1
         3            94         1         2         1
         4           118         2         2         1
         5           114         1         3         1
         6           104         1         1         2
 
TEST1567
  VECTOR_CONSTRAINED_NEXT3:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    CONSTRAINT = sum ( X(1:N) / X_MAX(1:N) )
  Accept only vectors for which:
    CONSTRAINT <= 1
 
  X_MIN:   1   1
  X_MAX:   5   6
 
         1    0.366667             1         1
         2    0.566667             2         1
         3    0.766667             3         1
         4    0.966667             4         1
         5    0.533333             1         2
         6    0.733333             2         2
         7    0.933333             3         2
         8    0.700000             1         3
         9    0.900000             2         3
        10    0.866667             1         4
 
  X_MIN:   1   1   1
  X_MAX:   5   6   4
 
         1    0.616667             1         1         1
         2    0.816667             2         1         1
         3    0.783333             1         2         1
         4    0.983333             2         2         1
         5    0.950000             1         3         1
         6    0.866667             1         1         2
 
TEST1568
  VECTOR_CONSTRAINED_NEXT4:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    TOTAL = sum ( ALPHA(1:N) * X(1:N) )
  Accept only vectors for which:
    TOTAL <= Q
 
  ALPHA:   4.00000       3.00000    
  Q:       20.0000    
  X_MIN:   1   0
  X_MAX:   2   6
 
         1     4.00000             1         0
         2     8.00000             2         0
         3     7.00000             1         1
         4     11.0000             2         1
         5     10.0000             1         2
         6     14.0000             2         2
         7     13.0000             1         3
         8     17.0000             2         3
         9     16.0000             1         4
        10     20.0000             2         4
        11     19.0000             1         5
 
  ALPHA:   4.00000       3.00000       5.00000    
  Q:       20.0000    
  X_MIN:   1   0   1
  X_MAX:   2   6   4
 
         1     9.00000             1         0         1
         2     13.0000             2         0         1
         3     12.0000             1         1         1
         4     16.0000             2         1         1
         5     15.0000             1         2         1
         6     19.0000             2         2         1
         7     18.0000             1         3         1
         8     14.0000             1         0         2
         9     18.0000             2         0         2
        10     17.0000             1         1         2
        11     20.0000             1         2         2
        12     19.0000             1         0         3
 
TEST1569
  VECTOR_CONSTRAINED_NEXT5:
  Generate integer vectors X such that:
    SUM_MIN <= sum ( X(1:N) ) <= SUM_MAX,
  We require every X(I) to be at least 1.
 
  N =              3
  SUM_MIN =        5
  SUM_MAX =        7
 
         #        X(1)      X(2)      X(3)
 
         1         3         1         1
         2         2         2         1
         3         2         1         2
         4         1         3         1
         5         1         2         2
         6         1         1         3
         7         4         1         1
         8         3         2         1
         9         3         1         2
        10         2         3         1
        11         2         2         2
        12         2         1         3
        13         1         4         1
        14         1         3         2
        15         1         2         3
        16         1         1         4
        17         5         1         1
        18         4         2         1
        19         4         1         2
        20         3         3         1
        21         3         2         2
        22         3         1         3
        23         2         4         1
        24         2         3         2
        25         2         2         3
        26         2         1         4
        27         1         5         1
        28         1         4         2
        29         1         3         3
        30         1         2         4
        31         1         1         5
 
TEST15695
  VECTOR_CONSTRAINED_NEXT6:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    TOTAL = sum ( ALPHA(1:N) * X(1:N) )
  Accept only vectors for which:
    Q_MIN <= TOTAL <= Q_MAX
 
  ALPHA:   4.00000       3.00000    
  Q_MIN:   16.0000    
  Q_MAX:   20.0000    
  X_MIN:   1   0
  X_MAX:   2   6
 
         1     16.0000             1         4
         2     19.0000             1         5
         3     17.0000             2         3
         4     20.0000             2         4
 
  ALPHA:   4.00000       3.00000       5.00000    
  Q_MIN:   16.0000    
  Q_MAX:   20.0000    
  X_MIN:   1   0   1
  X_MAX:   2   6   4
 
         1     19.0000             1         0         3
         2     17.0000             1         1         2
         3     20.0000             1         2         2
         4     18.0000             1         3         1
         5     18.0000             2         0         2
         6     16.0000             2         1         1
         7     19.0000             2         2         1
 
TEST15696
  VECTOR_CONSTRAINED_NEXT7:
  Consider vectors:
    0 <= X(1:N) <= X_MAX(1:N),
  Set
    TOTAL = sum ( ALPHA(1:N) * X(1:N) )
  Accept only vectors for which:
    Q_MIN <= TOTAL <= Q_MAX
 
  ALPHA:   4.00000       3.00000    
  Q_MIN:   16.0000    
  Q_MAX:   20.0000    
  X_MAX:   2   6
 
         1     18.0000             0         6
         2     19.0000             1         5
         3     17.0000             2         3
         4     20.0000             2         4
 
  ALPHA:   4.00000       3.00000       5.00000    
  Q_MIN:   16.0000    
  Q_MAX:   20.0000    
  X_MAX:   2   6   4
 
         1     20.0000             0         0         4
         2     18.0000             0         1         3
         3     19.0000             0         3         2
         4     17.0000             0         4         1
         5     20.0000             0         5         1
         6     18.0000             0         6         0
         7     19.0000             1         0         3
         8     17.0000             1         1         2
         9     20.0000             1         2         2
        10     18.0000             1         3         1
        11     19.0000             1         5         0
        12     18.0000             2         0         2
        13     19.0000             2         2         1
        14     17.0000             2         3         0
        15     20.0000             2         4         0
 
TEST15698
  VECTOR_NEXT:
  Generate all vectors X such that:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
 
  XMIN           1         4
     1           1         4
     2           2         4
     3           1         5
     4           2         5
     5           1         6
     6           2         6
  XMAX           2         6
 
  XMIN           1         4         3
     1           1         4         3
     2           2         4         3
     3           1         5         3
     4           2         5         3
     5           1         6         3
     6           2         6         3
     7           1         4         4
     8           2         4         4
     9           1         5         4
    10           2         5         4
    11           1         6         4
    12           2         6         4
  XMAX           2         6         4
 
TEST157
  YTB_ENUM counts Young table.
 
  N    YTB(N)
 
           0         0
           1         1
           2         2
           3         4
           4        10
           5        26
           6        76
           7       232
           8       764
           9      2620
          10      9496
 
TEST158
  YTB_NEXT generates Young tables.
 
 

 
   1   4   6
   2   5
   3
 

 
   1   3   6
   2   5
   4
 

 
   1   2   6
   3   5
   4
 

 
   1   3   6
   2   4
   5
 

 
   1   2   6
   3   4
   5
 

 
   1   4   5
   2   6
   3
 

 
   1   3   5
   2   6
   4
 

 
   1   2   5
   3   6
   4
 

 
   1   3   4
   2   6
   5
 

 
   1   2   4
   3   6
   5
 

 
   1   2   3
   4   6
   5
 

 
   1   3   5
   2   4
   6
 

 
   1   2   5
   3   4
   6
 

 
   1   3   4
   2   5
   6
 

 
   1   2   4
   3   5
   6
 

 
   1   2   3
   4   5
   6
 
TEST159
  YTB_RANDOM generates a random Young table
 

 
   1   2   6
   3   5
   4
 

 
   1   3   6
   2   4
   5
 

 
   1   3   6
   2   4
   5
 

 
   1   3   5
   2   4
   6
 

 
   1   2   5
   3   4
   6
 
SUBSET_PRB
  Normal end of execution.
 
 9 June 2011   3:46:27.033 PM
