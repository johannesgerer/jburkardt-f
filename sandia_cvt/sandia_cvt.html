<html>

  <head>
    <title>
      SANDIA_CVT - Centroidal Voronoi Tessellations: The Release Version
    </title>
  </head>

  <body bgcolor="#EEEEEE" link="#CC0000" alink="#FF3300" vlink="#000055">

    <h1 align = "center">
      SANDIA_CVT <br> Centroidal Voronoi Tessellations: The Release Version
    </h1>

    <hr>

    <p>
      <b>SANDIA_CVT</b>
      is a FORTRAN90 program which
      handles point placement, and moment determination, within arbitrary 2D
      or 3D regions.
    </p>

    <p>
      The program was written under contract to Sandia National Laboratory,
    </p>

    <p>
      The region is specified at a run time by an input file.  The input
      file is processed by a large geometry package known as DIATOM.
      This package is apparently a variant of a package known as CTH, both
      of which are used at Sandia.  DIATOM is written in C and FORTRAN.
    </p>

    <p>
      Sandia expected the CVT routines to be eventually included in the
      body of DIATOM, so that they would simply provide an option to
      determine point placement and moments, as part of a larger computation.
    </p>

    <p>
      For our testing, we included an interface with DIATOM, but we also
      made it possible to define the geometry of the region using a simple
      FORTRAN subroutine that simply says "yes, this point is in the region".
      By cutting out a few calls, the interface to DIATOM can be severed,
      and a standalone package can be produced for other purposes.
    </p>

    <p>
      <img src = "test_region.png" alt = "The test region and center points">
    </p>

    <p>
      Here is a picture of the test region.  The red points lie on the boundary
      and the black points lie within.  These data points were not generated
      by the Voronoi code.  Instead, 50,000 uniformly distributed points
      were generated in the bounding box, and then those points in or on
      the region were selected.  It's hard to tell from this picture, but
      a set of points selected from a uniform distribution tend to have
      voids and clusters, which will NOT occur in a Voronoi method.
    </p>

    <h3 align = "center">
      Licensing:
    </h3>

    <p>
      The computer code and data files described and made available on this web page
      are distributed under
      <a href = "../../txt/gnu_lgpl.txt">the GNU LGPL license.</a>
    </p>

    <h3 align = "center">
      Languages:
    </h3>

    <p>
      <b>SANDIA_CVT</b> is available in
      <a href = "../../f77_src/sandia_cvt/sandia_cvt.html">a FORTRAN77 version</a> and
      <a href = "../../f_src/sandia_cvt/sandia_cvt.html">a FORTRAN90 version</a>.
    </p>

    <h3 align = "center">
      Related Data and Programs:
    </h3>

    <p>
      <a href = "../../f_src/cvt/cvt.html">
      CVT</a>,
      a FORTRAN90 library which
      computes CVT's.
    </p>

    <p>
      <a href = "../../datasets/cvt/cvt.html">
      CVT</a>,
      a dataset directory which
      contains a variety of CVT datasets.
    </p>

    <p>
      <a href = "../../f_src/cvt_dataset/cvt_dataset.html">
      CVT_DATASET</a>,
      a FORTRAN90 program which
      computes CVT's.
    </p>

    <p>
      <a href = "../../f_src/lcvt/lcvt.html">
      LCVT</a>,
      a FORTRAN90 library which
      computes a latinized
      Centroidal Voronoi Tessellation.
    </p>

    <h3 align = "center">
      Reference:
    </h3>

    <p>
      <ol>
        <li>
          Franz Aurenhammer,<br>
          Voronoi diagrams -
          a study of a fundamental geometric data structure,<br>
          ACM Computing Surveys,<br>
          Volume 23, Number 3, pages 345-405, September 1991.
        </li>
        <li>
          John Burkardt, Max Gunzburger, Janet Peterson and Rebecca Brannon,<br>
          User Manual and Supporting Information for Library of Codes
          for Centroidal Voronoi Placement and Associated Zeroth,
          First, and Second Moment Determination,<br>
          Sandia National Laboratories Technical Report SAND2002-0099,<br>
          February 2002.
        </li>
        <li>
          Qiang Du, Vance Faber, and Max Gunzburger,<br>
          Centroidal Voronoi Tessellations: Applications and Algorithms,<br>
          SIAM Review, Volume 41, 1999, pages 637-676.
        </li>
        <li>
          John Halton,<br>
          On the efficiency of certain quasi-random sequences of points
          in evaluating multi-dimensional integrals,<br>
          Numerische Mathematik,<br>
          Volume 2, 1960, pages 84-90.
        </li>
        <li>
          Lili Ju, Qiang Du, and Max Gunzburger,<br>
          Probabilistic methods for centroidal Voronoi tessellations
          and their parallel implementations,<br>
          Parallel Computing,<br>
          Volume 28, 2002, pages 1477-1500.
        </li>
      </ol>
    </p>

    <h3 align = "center">
      Source Code:
    </h3>

    <p>
      <b>SANDIA_CVT</b> is the source code for the CVT library.
      <ul>
        <li>
          <a href = "sandia_cvt.f90">cvt.f90</a>, the program library;
        </li>
        <li>
          <a href = "sandia_cvt.sh">cvt.sh</a>, compiles the program library;
        </li>
        <li>
          <a href = "diatom_setup.c">diatom_setup.c</a>,
          some C interface routines that set up an interface with
          the DIATOM library;
        </li>
      </ul>
    </p>

    <p>
      <b>DIATOM_SETUP</b> is the source code for routines, written in C,
      that set up an interface with the DIATOM library.
      <ul>
        <li>
          <a href = "diatom_setup.c">diatom_setup.c</a>,
          the SANDIA_CVT-DIATOM interface routines;
        </li>
      </ul>
    </p>

    <p>
      <b>CVT_MAIN</b> is the text of a sample main program that calls the
      SANDIA_CVT library.  It does not require the DIATOM library.
      <ul>
        <li>
          <a href = "sandia_cvt_prb.f90">sandia_cvt_prb.f90</a>,
          the calling program;
        </li>
        <li>
          <a href = "sandia_cvt_prb.sh">sandia_cvt_prb.sh</a>,
          compiles, links and loads the calling program;
        </li>
      </ul>
    </p>

    <h3 align = "center">
      Examples and Tests:
    </h3>

    <p>
      <ul>
        <li>
          <a href = "fork_2d.in">fork_2d.in</a>, a DIATOM input file
          that defines a 2D test region;
        </li>
        <li>
          <a href = "fork_3d.in">fork_3d.in</a>, a DIATOM input file
          that defines a 3D test region;
        </li>
        <li>
          <a href = "diatom_test.in">diatom_test.in</a>, a DIATOM 3D
          geometry file;
        </li>
        <li>
          <a href = "diatom_point_test2.c">diatom_point_test2.c</a>, uses
          DIATOM to determine if a point is in the region;
        </li>
        <li>
          <a href = "diom_globals.h">diom_globals.h</a>, a DIATOM include
          file referenced by DIATOM_POINT_TEST2.C.
        </li>
        <li>
          <a href = "diom_procedures.h">diom_procedures.h</a>, a DIATOM
          include file referenced by DIATOM_POINT_TEST2.C.
        </li>
      </ul>
    </p>

    <h3 align = "center">
      Output Data Files:
    </h3>

    <p>
      <ul>
        <li>
          <a href = "cvt_01_output.txt">cvt_01_output.txt</a>, 64 generators, no bins,
          228 CPU seconds.
        </li>
        <li>
          <a href = "cvt_02_output.txt">cvt_02_output.txt</a>, 64 generators, 25x25x5 bins,
          188 CPU seconds.
        </li>
        <li>
          <a href = "cvt_03_output.txt">cvt_03_output.txt</a>, 128 generators, no bins,
          739 CPU seconds.
        </li>
        <li>
          <a href = "cvt_04_output.txt">cvt_04_output.txt</a>, 128 generators, 25x25x5 bins,
          375 CPU seconds.
        </li>
        <li>
          <a href = "cvt_05_output.txt">cvt_05_output.txt</a>, 256 generators, no bins,
          2638 CPU seconds.
        </li>
        <li>
          <a href = "cvt_06_output.txt">cvt_06_output.txt</a>, 256 generators, 25x25x5 bins,
          807 CPU seconds.
        </li>
        <li>
          <a href = "cvt_07_output.txt">cvt_07_output.txt</a>, 512 generators, no bins,
          9960 CPU seconds.
        </li>
        <li>
          <a href = "cvt_08_output.txt">cvt_08_output.txt</a>, 512 generators, 25x25x5 bins,
          1818 CPU seconds.
        </li>
        <li>
          <a href = "cvt_09_output.txt">cvt_09_output.txt</a>, 1024 generators, no bins,
          41329 CPU seconds.
        </li>
        <li>
          <a href = "cvt_10_output.txt">cvt_10_output.txt</a>, 1024 generators, 25x25x5,
          4191 CPU seconds.
        </li>
        <li>
          <a href = "cvt_generators.txt">cvt_generators.txt</a>, the Voronoi
          cell generators;
        </li>
        <li>
          <a href = "cvt_volume.txt">cvt_volume.txt</a>, the cell volumes;
        </li>
        <li>
          <a href = "cvt_centroid.txt">cvt_centroid.txt</a>, the cell centroids;
        </li>
        <li>
          <a href = "cvt_moment.txt">cvt_moment.txt</a>, the cell second
          moment matrices;
        </li>
      </ul>
    </p>

    <h3 align = "center">
      List of Routines:
    </h3>

    <p>
      <ul>
        <li>
          <b>BIN_PREPROCESS</b> organizes the preprocessing step for bins.
        </li>
        <li>
          <b>BIN_TO_R8_EVEN2</b> returns the limits for a given "bin" in [A,B].
        </li>
        <li>
          <b>BIN_TO_R8VEC_EVEN3</b> returns the limits for a given R8VEC "bin" in [A,B].
        </li>
        <li>
          <b>CVT_ITERATION</b> takes one step of the CVT iteration.
        </li>
        <li>
          <b>FIND_CLOSEST</b> finds the Voronoi cell generator closest to a point X.
        </li>
        <li>
          <b>GENERATOR_INIT</b> initializes the Voronoi cell generators.
        </li>
        <li>
          <b>I4_TO_HALTON_VECTOR</b> computes an element of a vector Halton sequence.
        </li>
        <li>
          <b>INDEX_BOX2_NEXT_2D</b> produces indices on the surface of a box in 2D.
        </li>
        <li>
          <b>INDEX_BOX2_NEXT_3D</b> produces indices on the surface of a box in 3D.
        </li>
        <li>
          <b>POINTS_NEAREST_POINT_BINS3_2D</b> finds the nearest point to a given point in 2D.
        </li>
        <li>
          <b>POINTS_NEAREST_POINT_BINS3_3D</b> finds the nearest point to a given point in 3D.
        </li>
        <li>
          <b>QUALITY</b> computes some quality measures for a set of points in a region.
        </li>
        <li>
          <b>R8_TO_BIN_EVEN2</b> determines the appropriate "bin" for C in [A,B].
        </li>
        <li>
          <b>R82VEC_BIN_EVEN3</b> bins a D2 array into evenly spaced bins.
        </li>
        <li>
          <b>R82VEC_BINNED_REORDER2</b> reorders a binned D2 data vector.
        </li>
        <li>
          <b>R82VEC_BINNED_SORT_A2</b> sorts each bin of a D2 binned data vector.
        </li>
        <li>
          <b>R83VEC_BIN_EVEN3</b> bins a D3 array into evenly spaced bins.
        </li>
        <li>
          <b>R83VEC_BINNED_REORDER2</b> reorders a binned D3 data vector.
        </li>
        <li>
          <b>R83VEC_BINNED_SORT_A2</b> sorts each bin of a D3 binned data vector.
        </li>
        <li>
          <b>R8COL_PART_QUICK_A</b> reorders the columns of an array as part of a quick sort.
        </li>
        <li>
          <b>R8COL_SORT_QUICK_A</b> ascending sorts the columns of a table using quick sort.
        </li>
        <li>
          <b>R8MAT_DET_2D</b> computes the determinant of a 2 by 2 matrix.
        </li>
        <li>
          <b>R8MAT_DET_3D</b> computes the determinant of a 3 by 3 matrix.
        </li>
        <li>
          <b>R8VEC_EQ</b> is true if every pair of entries in two vectors is equal.
        </li>
        <li>
          <b>R8VEC_GT</b> == ( A1 > A2 ) for double precision vectors.
        </li>
        <li>
          <b>R8VEC_LT</b> == ( A1 < A2 ) for double precision vectors.
        </li>
        <li>
          <b>R8VEC_SWAP</b> swaps the entries of two double precision vectors.
        </li>
        <li>
          <b>R8VEC_TO_BIN_EVEN3</b> determines the appropriate "bin" for a R8VEC value.
        </li>
        <li>
          <b>RANDOM_INITIALIZE</b> initializes the FORTRAN 90 random number seed.
        </li>
        <li>
          <b>REGION_SAMPLER</b> returns a sample point in the physical region.
        </li>
        <li>
          <b>TIMESTAMP</b> prints the current YMDHMS date as a time stamp.
        </li>
        <li>
          <b>VCM</b> calculates Voronoi cell volumes, centroids and second moments.
        </li>
      </ul>
    </p>

    <p>
      You can go up one level to <a href = "../f_src.html">
      the FORTRAN90 source codes</a>.
    </p>

    <hr>

    <i>
      Last revised on 31 January 2010.
    </i>

    <!-- John Burkardt -->

  </body>

</html>
